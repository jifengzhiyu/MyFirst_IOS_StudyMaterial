1.演示私人通讯录
    • 学习目的：控制器跳转，控制器之间传值，数据存储

2.项目演示：(4个界面，交给4个控制器管理)
    1>  登录界面：
        ○ 登录按钮只有文本框都有文字才能点击
        ○ 文本框有占位符，提示用户输入什么。
        ○ 密码文本框是暗文，密码属于机密，不需要显示出来。
        ○ 当文本框输入文字，会显示清除按钮，提高用户体验。
        ○ 开关细节注意：当打开自动登录，记住密码也会打开，当关闭记住密码，自动登录也会打开。
        ○ 点击登录，会判断账号和密码是否正确，只有正确输入才会进入下一个界面，并且提示用户正在登录，模拟网络延迟。
    2> 联系人列表界面
        ○ 联系人列表界面导航条的标题跟账号有关系(控制器之间传值，把登录界面的账号传递过来)
        ○ 注销按钮，回到登录界面
        ○ 添加按钮进入添加联系人界面
    3> 添加联系人界面
        ○ 默认弹出姓名的文本框，不需要用户点击文本框弹出键盘，人性化设计。
        ○ 添加按钮，只有文本框都有内容才能点击
        ○ 点击添加按钮，回到联系人列表界面，并且把数据显示到联系人列表界面（控制器之间传值）
    4> 编辑联系人界面
        ○ 点击cell,进入编辑联系人界面
        ○ 默认保存按钮是隐藏的。
        ○ 默认文本框不能交互，一开始是查看联系人。
        ○ 当点击编辑按钮的时候，文本框才允许交互，并且保存按钮默认不能点击
        ○ 默认弹出电话文本框，一般修改联系人信息，大部分都是改电话，人性化设计。
        ○ 编辑状态的时候，点击取消按钮，会恢复修改的文本框数据，重新回到查看联系人界面。
        ○ 编辑状态的时候，点击保存按钮，更新最新的数据，展示在联系人列表界面。

3.分析项目框架（项目第一步）
    1> 有导航条，而且需要进行跳转，项目框架采取导航控制器。

4.分析项目开发方式：采用纯代码还是storyboard.
    1> 界面都是固定死，而且界面比较少，用storyboard开发，能快速进行界面之间的跳转。

5.搭建项目框架
    1> 程序一启动就会加载storyboard中箭头所指向的控制器，箭头所指向的控制器换成导航控制器。

6.搭建登录界面，完善登录界面功能
    1> 程序一启动，就是登录界面，因此导航控制器的根控制器就是登录控制器。
    2> 处理登录按钮细节，当文本框都有内容的时候，才允许登录按钮点击。
    • 代理能监听文本框的内容，不能实时监控文本框的内容改变，不能采取代理方式。
    • 只能监听上一次输入，不能监听当前输入文本框内容。
    • 通知也能监听文本框的内容，文本框的内容一改变，文本框就会发出通知。
    • UITextField继承UIControll,可以addTarget监听。
    3> 处理开关按钮细节
    • 当打开自动登录，自动打开记住密码开关
    • 当打开记住密码，自动打开自动登录开关
    4> 点击登录按钮，跳转到联系人界面

7. 搭建联系人界面
    1> 继承UITableViewController
    2> 注销功能
    • 弹出UIActionSheet，destructiveButtonTitle一般显示比较危险的操作标题。
    • 监听UIActionSheet按钮点击，通过代理。
    • 按钮角标从上往下，依次拯救，最上面按钮角标为0.
    • 点击确定按钮，回到登录界面

8. 完善登录功能
    1> 点击登录不应该自动跳转，而且需要判断账号和密码是否正确。
    2> 连线的方式不对，应该控制器之间连线，控制器之间连线，就不知道什么时候做跳转，只知道从哪个控制器跳转到另外一个控制器。这种方式，需要手动执行跳转。PPT演示segue。
    3> 登录业务逻辑分析：
    • 如果账号和密码输入正确，就直接跳转到下一个界面，不需要提示用户是否输入正确，跳转界面是最好的提示，手动执行segue,必须用来源控制器调用performSegueWithIdentifier,否则会报错，而且segue标识必须正确，否则也会报错。
    • 如果账号和密码输入错误，就提示用户输入错误，用UIAlertView不会自动取消提示框，一般用第三方框架提示MBProgressHud。
    • 最好模仿网络处理延迟，2秒后判断是否输入正确。用GCD延迟
    • 延迟这段时间，最好搞个蒙版提示用户正在干嘛，蒙版的作用就是2秒内提示用户，而且不允许用户与界面交互，做其他不好的操作。2秒后，就自动销毁。

    4> 登录成功后，需要把登录账户传递给联系人控制器，显示到导航条的标题上
        • 顺传：上一个控制器传递给下一个控制器
        • 思路：
        • 第一步：有属性接收登录账户，联系人控制器的navgationItem.title接收这个属性
        • 第二步：拿到联系人控制器给他的navgationItem.title这个属性赋值，把账户传递给他。
        • 第三步：怎么拿到联系人控制器，通过segue对象，segue对象的目的控制器就是下一级控制器联系人控制器。segue怎么拿？不能自己创建一个联系人控制器，应该拿到storyboard帮我们创建的联系人控制器.
             1> 分析performSegueWithIdentifier方法底层做的事情。
             2> 通过prepareForSegue这个方法拿。
             3> prepareForSegue什么时候调用：在执行segue后，跳转之前调用
             4> prepareForSegue方法作用：在跳转之前，做一些准备工作，一般给跳转的下一个控制器传值。
9. 搭建添加联系人界面
    1> 点击添加按钮，进入添加联系人界面
    2> 默认添加按钮不允许点击，跟登录界面做一样的判断
    3> 默认弹出姓名文本框，人性化设计
    4> 点击添加，把数据传到联系人界面，展示出来。
        • 回传：下一个控制器，传递给上一个控制器
        • 第一种方式：
          1.给添加控制器添加一个联系人控制器的属性，拿到联系人控制器，才能做事情。
          2.添加控制器怎么拿到联系人控制器？在联系人控制器跳转到添加控制器之前，给添加控制器的联系人控制器属性赋值。
          3.耦合性太强，设计不好，两个控制器太依赖了
        • 第二种方式：
          1.通过代理
          2.谁作为添加联系人的代理：联系人控制器，监听添加联系人。
          3.只要添加一个联系人，就通知联系人控制器
          4.什么时候给添加联系人的代理赋值：在联系人控制器跳转到添加控制器之前，给添加控制器的代理属性赋值。

10.总结控制器之间的传值
    顺传：上一级控制器传递给下一级控制器，直接能拿到下一级控制器，拿到之后，做什么事情都行。
    回传：下一级控制器传递给上一级控制器，用代理。上一级控制器作为下一级的代理，监听下一级控制器的事情。

11.完善联系人界面
    1> 搞个数组，保存所有联系人，因为不只添加一个联系人。
    2> 实现tableView的数据源方法，展示联系人界面。
    3> 监听到添加联系人的时候，就把联系人添加到数组，然后刷新表格。

12.搭建编辑联系人界面
    1> 默认文本框不允许交互
    2> 默认保存按钮是隐藏的。
    3> 当点击编辑按钮，文本框允许交互，并且默认弹出电话的键盘
    4> 编辑状态的时候，点击取消按钮，会恢复修改的文本框数据，重新回到查看联系人界面。
    • 模型里面的数据一直没有改变，给文本框重新赋值原来的属性就OK了。
    5> 编辑状态的时候，点击保存按钮，更新最新的数据，展示在联系人列表界面。
    • 更新模型的数据，然后直接刷新联系人控制器的界面就好。
    • 原因：编辑控制器的模型就是联系人控制器选中cell的模型，只需要那模型里面的属性更新下就好了。

13.处理tableView分割线
    1> tableView中有些分割线没必要显示，只有有数据才需要显示
    2> 怎么取消分割线？进入头文件搜separator
    • 首先肯定会去找cell头文件，有没有提供一个属性，取消分割线，没有。
    • 然后去tableView头文件里找，有没有提供一个属性，取消分割线，
    3> 发现整个tableView都没有分割线了，有数据的cell需要分割线，怎么做？自己添加分割线。
    • 第一种方式，把分割线添加到tableView上，太麻烦了，每个分割线的位置不好计算
    • 第二种方式，给cell添加分割线，分割线的位置计算比较简单。
    4> 自定义cell,系统自带的不好用，不能添加分割线，分割线添加到contentView上。
    • 封装思想：自己的东西自己管理，以后开发有同样的，直接拿过去就好了，最好提供一个快速创建对象的类方法。提供模型，重写模型的set方法，传递模型过来，就给控件赋值。
    • 分割线的位置，在哪设置比较准确？一创建的时候设置是不准确的，cell的位置和尺寸是由tableView决定的，因此不能在awakeFromNib里设置。
        1. awakeFromNib什么时候调用？xib加载完成的时候调用
        2. awakeFromNib的作用:从控件从xib加载完成之后，做一些初始化操作。
        3. 在layoutSubViews设置尺寸。

14.数据存储(数据持久化)
    1> 介绍iOS数据存储的5种方式
    2> 介绍应用沙盒(应用程序的文件夹)
    • 如何找到应用沙盒的路径？首先需要显示隐藏文件。
    • 点击前往->个人->资源库->Application Support->iPhone Simulator->7.1->里面全是应用沙盒
    3> 应用沙盒怎么多文件夹保存，在哪个文件夹。介绍沙盒里的每一个文件夹。

15.plist存储
    • 把一些系统自带的OC对象生成pilst文件存储起来。
    1> 了解数据存储：数据存储一般有两个操作，一个存，一个取。拖两个按钮，一个用来存，一个用来取
    2> plist存储原理：
    • 只要有writeToFile的对象，就能进行plist存储，调用writeToFile就能自动生成plist格式的文件。
    • 一般常用的Foundation对象都有这个方法，数组，字典，字符串等
    3> 如何写入到沙盒，需要获取沙盒路径。
    • 获取Documents路径
    • 拼接文件名，因为数据是写入到文件中，不是写入到文件夹中。路径之间通过/分开的，为了避免自己写/，会用stringByAppendingPathCompent，自动在文件夹与文件之间添加/。
    4> 如何读取，存储是什么类型存储，读取出来也是什么类型，直接用存储的类型，解析文件就好，用ContentsOfFile解析。
    5> 注意plist存储，不能存储自定义对象，会失败的。

16> 偏好设置
    1> 什么是偏好设置存储：就是保存一些基本的信息，账号，密码，状态。
    2> 偏好设置原理：不需要关心文件名，直接通过NSUserDefaults操作，默认就存到偏好设置里面了。
    • 通过NSUserDefaults就能直接访问软件的偏好设置(Library/Preferences)
    3> 怎么利用偏好设置存储?利用NSUserDefaults调用setObject:forKey存储。
    • 偏好设置底层实现原理：底层其实就是利用一个字典，存储一些键值对。
    • 偏好设置好处：能快速存储一些键值对，如果用字典去存储，还需要获取文件名比较麻烦。
    • 偏好设置坏处：不能及时存储，需要做同步操作，把内存中的数据同步到硬盘上。
    4> 怎么利用偏好设置读取?和字典一样，根据刚刚存储的Key读取。

17> 自定义对象归档(归档：数据存储)
    1> 自定义对象如何归档：用NSKeyedArchiver,调用archiveRootObject:toFile:方法，需要传一个对象，自定义一个对象，传进去。
    •  会报错,说对象没有encodeWithCoder方法，说明归档的时候默认会调用这个方法，去实现这个方法。
    • 默认打不出encodeWithCoder，必须遵守NSCoding协议才能实现这个方法。
    • encodeWithCoder什么时候调用：对象归档时候调用
    • encodeWithCoder作用：告诉系统对象里的哪些属性需要归档，怎么去归档，根据一个key去归档，目的就是以后取的时候，也根据这个key去取数据。
    2> 自定义对象如何解档:用NSKeyedUnarchiver,调用unarchiveObjectWithFile方法，需要传一个文件名。
    • 会报错,说对象没有initWithCoder方法，说明解档的时候默认会调用这个方法，去实现这个方法。
    • initWithCoder什么时候调用：对象解档时候调用
    • initWithCoder作用：告诉系统对象里的哪些属性需要解档，怎么去解档，根据之前存储的key去解档
    • initWithCoder是一个初始化方法，需要先初始化父类的，但是不能调用[super initWithCoder:],因为父类NSObject没有遵守NSCoding协议。
    3> initWithCoder什么时候需要调用[super initWithCoder:]
    • initWithCoder原理:只要解析文件就会调用，xib,storyboard都是文件，因此只要解析这两个文件，就会调用initWithCoder。
    • 因此如果在storyboard使用自定义view,重写initWithCoder方法，一定要调用[super initWithCoder:]，因为只有系统才知道怎么解析storyboard，如果没有调用，就解析不了这个文件。
