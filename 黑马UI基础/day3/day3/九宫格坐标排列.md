# 代码结构

![image-20210902161214324](%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9D%90%E6%A0%87%E6%8E%92%E5%88%97.assets/image-20210902161214324.png)

# 九宫格算法

![image-20210902163815008](%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9D%90%E6%A0%87%E6%8E%92%E5%88%97.assets/image-20210902163815008.png)

![image-20210902165532136](%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9D%90%E6%A0%87%E6%8E%92%E5%88%97.assets/image-20210902165532136.png)

确定哪个格子：

格子数字取余（一行的格子数），就知道该格子在一行中的位置(列的索引)   

格子数字取商（一列的格子数），就知道该格子在一列中的位置(行的索引)   

![image-20210903170005477](%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9D%90%E6%A0%87%E6%8E%92%E5%88%97.assets/image-20210903170005477.png)

 # 子控件

![image-20210903202509671](%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9D%90%E6%A0%87%E6%8E%92%E5%88%97.assets/image-20210903202509671.png)

**子控件的x,y值相对于它的父控件而言**

# 控件的最大值X，Y

```objective-c
CGFloat btnY = CGRectGetMaxY(lblName.frame);
        //CG_EXTERN CGFloat CGRectGetMaxY(CGRect rect)
        //@property(nonatomic) CGRect            frame;

        //控件的最大Y值 = Y +控件的高度
        //控件的最大X值 = X + 控件的宽度
```

# 按钮的字体

按钮由lible(文字）和imageView（图片，背景等等）

```objective-c
 //设置按钮的文字大小
        btnDownload.titleLabel.font = [UIFont systemFontOfSize:14];
```

# 单击事件

```objective-c
//为按钮注册一个单击事件
        [btnDownload addTarget:self action:@selector(btnDownloadClick) forControlEvents:UIControlEventTouchUpInside];   
```

![image-20210903225232242](%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9D%90%E6%A0%87%E6%8E%92%E5%88%97.assets/image-20210903225232242.png)

# 字典转模型

字典：字典数组

模型：类（以及属性）

- 字典转模型：将字典数组转换成类的属性

属性的个数依据字典数组中键值对的个数，将字典对象的键值对的值转化成对象的属性

**不论ARC还是MRC模式，如果属性的类型是NSString，@property使用copy参数**

**把传进来的字符串copy一份再赋值**

- 好处：有提示，编译会报错，对象延展性高

```objective-c
/// 懒加载,字典转模型
-(NSArray*)apps{
    if(_apps == nil){
        //加载数据
        //1、获取app.plist在手机上的路径
        NSString * path = [[NSBundle mainBundle] pathForResource:@"app.plist" ofType:nil];
        //2、根据路径加载数据
        NSArray * arrayDict = [NSArray arrayWithContentsOfFile:path];
        //3、创建一个可变数组来保存模型对象
        NSMutableArray * arrayModels = [NSMutableArray array];
        //4、循环字典数组，将每一个字典对象转化为一个模型对象
        for(NSDictionary *dict in arrayDict){
            //创建一个模型
            APP * modle = [[APP alloc] init];
            modle.name = dict[@"name"];
            modle.icon = dict[@"icon"];
            
            //把模型添加到可变数组中去
            [arrayModels addObject:modle];
        }
        _apps = arrayModels;
    }
    return _apps;
}
```

![image-20210904101517538](%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9D%90%E6%A0%87%E6%8E%92%E5%88%97.assets/image-20210904101517538.png)

# 初始化模型封装的方法

```objective-c
/// 对象方法，初始化并赋值初始数据
/// @param dict for in下来的每一个字典数组
- (instancetype)initWithDict:(NSDictionary *)dict
{
    if(self = [super init]){
        self.name = dict[@"name"];
        self.icon = dict[@"icon"];
    }
    return self;
}
+(instancetype)appWithDict:(NSDictionary *)dict{
    return [[self alloc] initWithDict:dict];
}//类方法，创建对象
```

**以后写模型，要声明属性，并封装上述两个方法**

封装上述属性，返回值选用instancetype，为了延长扩展性

如果有子类继承该类的话，就会返回子类对象

//如果返回父类对象的话，就无法使用子类对象特有的方法和属性

Instancetype：哪个对象用这个方法，就返回哪个对象

# 字典转化模型的步骤

1、 创建模型（类）

2、给类封装两个方法

3、在懒加载数据的时候，把加载到的数据放在模型对象中，把模型对象放在数组中

# xib封装

- Xib 的创建

安装之后显示.nib文件

![image-20210904110903416](%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9D%90%E6%A0%87%E6%8E%92%E5%88%97.assets/image-20210904110903416.png)

- 改变大小
- ![image-20210904111711885](%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9D%90%E6%A0%87%E6%8E%92%E5%88%97.assets/image-20210904111711885.png)

# xib的加载

```objective-c
        //通过xib创建每个应用UIVeiw
        //通过动态加载xib文件创建里面的view
        //1.1)找到xib所在应用的根目录
        NSBundle * rootBundle = [NSBundle mainBundle];
        //NSLog(@"%@",[mainBundle bundlePath]);
        //1.2)在根目录里面找到xib文件并加载
        AppView * appView = [[rootBundle loadNibNamed:@"AppView" owner:nil options:nil] lastObject];
        //loadNibNamed。。。方法返回值是NSArray,里面参数不用写xib后缀（本来就是专门针对xib）
        //lastObject返回值id
```

![image-20210904190603342](%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9D%90%E6%A0%87%E6%8E%92%E5%88%97.assets/image-20210904190603342.png)

根源素：如下图有四个

![image-20210904190727047](%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9D%90%E6%A0%87%E6%8E%92%E5%88%97.assets/image-20210904190727047.png)



# xib使用控件必须自定义一个类

如果是系统的UIView类就不能添加属性，需要自定义一个类

在自定义一个类里面自定义方法

新建：
![image-20210904120801483](%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9D%90%E6%A0%87%E6%8E%92%E5%88%97.assets/image-20210904120801483.png)

![image-20210904120900704](%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9D%90%E6%A0%87%E6%8E%92%E5%88%97.assets/image-20210904120900704.png)

- 拖线拖在.h文件（可以从外界访问）

如果拖到.m文件到类扩展，就无法从外界访问

# xib的使用

作为一个大view的小view使用

# 下载项目总结

1、模型

2、懒加载

3、xib, view

4、1，3结合

模块化设计（封装）

# 目录

![image-20210904185910232](%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9D%90%E6%A0%87%E6%8E%92%E5%88%97.assets/image-20210904185910232.png)

# 点击按钮下载功能

- 自定义view里面不能访问控制器的view

- 文字粗体

```objective-c
//3.6文字粗体
    lblMsg.font = [UIFont boldSystemFontOfSize:30];
```

- 透明度

```objective-c
//3.7透明度
    lblMsg.alpha = 0.5;
    //0完全透明，1完全不透明
```

- 设置圆角

设置半径，确定剪裁

```objective-c
//3.8设置圆角
    lblMsg.layer.cornerRadius = 20;
    lblMsg.layer.masksToBounds = YES;
```

- 逐步显现出来

动画

一开始透明度是0，慢慢把透明度提高

