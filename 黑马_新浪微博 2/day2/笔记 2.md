# 构造函数

![image-20211118163241445](%E7%AC%94%E8%AE%B0.assets/image-20211118163241445.png)

**构造函数的使命：通过构造函数创建对象，该对象要给其所有的属性分配空间 并 设置初始值**

# 调用堆栈

- 调试

![image-20211118165304624](%E7%AC%94%E8%AE%B0.assets/image-20211118165304624.png)

堆栈特点：后进先出，越往上越新

# 重载 & 重写

- 重载

  - 函数名相同，参数名／参数类型／参数个数不同

  - 重载函数并不仅仅局限于`构造函数`
  - 函数重载是面相对象程序设计语言的重要标志
  - 函数重载能够简化程序员的记忆
  - OC 不支持函数重载，OC 的替代方式是 `withXXX...`

- `重写`，子类需要在父类拥有方法的基础上进行扩展，需要 `override` 关键字

# KVC构造函数（指定构造函数）

![image-20211118203824021](%E7%AC%94%E8%AE%B0.assets/image-20211118203824021.png)

```swift
  init(dict: [String: AnyObject]) {
  }
//规定参数类型是KVC，没有规定数量
//setValuesForKeysWithDictionary(dict) 规定参数的数量，键值对的数量和属性一样

var name: String?
自带构造函数 init 
```

![image-20211118225414308](%E7%AC%94%E8%AE%B0.assets/image-20211118225414308.png)

- 出现了问题

 https://blog.csdn.net/qq_28091923/article/details/86607226

KVC机制由一个协议定义，NSObject实现了这个协议。swift对象没有像OC对象一样（都继承NSObject），所以swift里面使用KVC要显式地声明继承自 NSObject。

# 便利构造函数

## deinit析构函数

![image-20211119231052476](%E7%AC%94%E8%AE%B0.assets/image-20211119231052476.png)

![image-20211119231905860](%E7%AC%94%E8%AE%B0.assets/image-20211119231905860.png)

- ARC需要在deinit里面清理以上三点

![image-20211119233300843](%E7%AC%94%E8%AE%B0.assets/image-20211119233300843.png)

# URLSession

https://juejin.cn/post/7032635033554780167/

又被老视频坑了

先列代码，再一点点分析

以下代码是别人的：在别的网站上找到的

https://www.jianshu.com/p/7cec65324a9b

```swift
let urlString:String = "http://www.weather.com.cn/data/sk/101010100.html"
var url:URL!
    url = URL(string:urlString)
    //发出请求
    URLSession.shared.dataTask(with: url) { (objectData, response, error) in
    guard error == nil else {
    print("网络出错:\(error!.localizedDescription)")
    return
    }
                

    guard objectData != nil else {
        print("数据为空：")
        return
    }


    do {
        let jsonData = try JSONSerialization.jsonObject(with: objectData!, options: .mutableContainers)
        print(jsonData)

    } catch {
        print("解析出错")
    }

    }.resume()

作者：想吃酸菜鱼
链接：https://juejin.cn/post/7032635033554780167/
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```swift
//原码
let urlString:String = "http://www.weather.com.cn/data/sk/101010100.html"
var url:URL!
url = URL(string:urlString)
//改进 一步到位
let url = URL(string: "http://www.weather.com.cn/data/sk/101010100.html")!

作者：想吃酸菜鱼
链接：https://juejin.cn/post/7032635033554780167/
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```swift
let url = URL(string: "http://www.weather.com.cn/data/sk/101010100.html")!
URLSession.shared.dataTask(with: url) { data, _, _ in
do {
    let jsonData = try JSONSerialization.jsonObject(with: data!, options: [])
    print(jsonData)

} catch {   // 如果反序列化失败，能够捕获到 json 失败的准确原因，而不会崩溃
    print(error)
}

}.resume()

作者：想吃酸菜鱼
链接：https://juejin.cn/post/7032635033554780167/
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

# 闭包的循环引用

![image-20211120214943185](%E7%AC%94%E8%AE%B0.assets/image-20211120214943185.png)

如果不定义完成后回调属性的话，不会产生循环引用问题，因为finished里面打印self会在实现该语句之后 切段联系

如果定义成属性，就会牢牢把finishedCellBack finished绑住。finished就和VC绑住了

![image-20211120220400089](%E7%AC%94%E8%AE%B0.assets/image-20211120220400089.png)

![image-20211120221417440](%E7%AC%94%E8%AE%B0.assets/image-20211120221417440.png)

# 通讯录

- 嵌入导航控制器

![image-20211121195613766](%E7%AC%94%E8%AE%B0.assets/image-20211121195613766.png)

选中目标vc

- 监控textField

![image-20211121201039901](%E7%AC%94%E8%AE%B0.assets/image-20211121201039901.png)

## 在DetailViewController didSet中设置界面数据有风险

```swift
  /// 个人数据模型
    var person: Person?
//    {
        didSet {
//            // 在传递数值的时候，控制器已经被创建，但是控制器的视图没有被创建！
//            // 视图没有被创建，那么子视图同样没有创建
//            // EXC_BAD_INSTRUCTION 野指针访问  访问的没有数据
//            
//            // 一旦使用了 view，如果 view == nil，会调用 loadView() 创建 view以及子视图
          //因为使用SB创建所以就直接load子控件
            print(view)
            
            nameText.text = person?.name
            ageText.text = "\(person?.age ?? 0)"
        }
    }
```

跳转didSet person是在  override func prepare(for segue: UIStoryboardSegue, sender: Any?) 里面设置person数据的

没有经过loadView，所以无法设置界面显示数据

MyTableViewController里面可以这么干

