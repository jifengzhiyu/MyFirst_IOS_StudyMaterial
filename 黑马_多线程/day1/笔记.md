# 字符串的栈 堆

1、栈区（stack）— 由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。

3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。

4、文字常量区 —常量字符串就是放在这里的。程序结束后由系统释放。

5、程序代码区—存放函数体的二进制代码。



作者：紫云夕月
链接：https://www.jianshu.com/p/8588981a74de
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

- NSString的栈 堆

alloc分配内存空间，这个时候空间是分配到堆上的

直接写字符串，空间分配到常量区

```objective-c
NSString *str = @"这个在常量区";
NSString *str = [NSString stringWithFormat @"这个在堆区%d",i];
```

# 运行速度

![image-20211017234154884](%E7%AC%94%E8%AE%B0.assets/image-20211017234154884.png)

- I/O操作：input output

涉及到了操控外部设备所以慢

- 最慢的是网络

# 界面卡死

- 叫做：阻塞

# 多线程的概念

## 同步/异步

- 同步：代码从上往下一行一行执行

同一时间执行同一个任务

- 异步：同时执行多个任务

## 进程/线程

- 进程：运行的一个应用

![image-20211017235123002](%E7%AC%94%E8%AE%B0.assets/image-20211017235123002.png)

- 一个公司（进程），员工（一个个线程）

## 多线程

- 多个公司

![image-20211017235506013](%E7%AC%94%E8%AE%B0.assets/image-20211017235506013.png)

- 老板也是一个线程：主线程

# 多线程执行原理

# 单任务操作系统/多任务操作系统

- 单任务操作系统：只有进程，没有线程概念
- 多任务操作系统：cpu可以同时执行不同任务（通过切换的方式

----

## 单核CPU

- 多任务操作系统：通过切换的方式

时间到了，把第一个线程断开，内容保存在内存里，执行下一个线程

如此循环，把第一轮线程执行一段的时间，之后回到第一个线程。

加载第一个线程，读取内存数据，继续执行，时间到了，把第一个线程断开，内容保存在内存里，执行下一个线程

执行完了的线程会清除掉，不再执行

![image-20211018143858013](%E7%AC%94%E8%AE%B0.assets/image-20211018143858013.png)

- 多核CPU就可以 真正 同时处理多个线程（几核同时处理几个线程

- 切换线程就像是循环，线程太多会消耗cpu性能

切换线程也消耗时间

或者线程多就像把一个任务分给几百个人，光是布置任务的时间就足够让四五个人完成

- 一般3-6个线程

# 多线程优缺点

![image-20211018144918652](%E7%AC%94%E8%AE%B0.assets/image-20211018144918652.png)

- 线程间的通信：传递数据

- 多线程的数据共享：多个线程同时给一个变量赋值

# 主线程

![image-20211018145043719](%E7%AC%94%E8%AE%B0.assets/image-20211018145043719.png)

- 主线程：系统开的，在main函数里面执行

- UI线程：![image-20211018145429258](%E7%AC%94%E8%AE%B0.assets/image-20211018145429258.png)

UIApplicationMain--->AppDelegate(程序生命周期)--->didFinishLaunchingWithOptions(创建windw,controller及其view和子控件)

# IOS多线程技术方案

![image-20211018150134628](%E7%AC%94%E8%AE%B0.assets/image-20211018150134628.png)

- 方法是属于对象的

- mac OS系统基于unix

# pthread

- 三种方式里面，唯一可跨平台的

![image-20211018151918468](%E7%AC%94%E8%AE%B0.assets/image-20211018151918468.png)

- _t结尾多是c语言的数据类型

- Void *  函数返回值（任何类型的指针

（*）函数名，本质就是地址

(void * ) 参数（任何类型的指针

- 更正：

![image-20211018154429212](%E7%AC%94%E8%AE%B0.assets/image-20211018154429212.png)

![image-20211018154504574](%E7%AC%94%E8%AE%B0.assets/image-20211018154504574.png)

## 演示 不带参数

![image-20211018155955357](%E7%AC%94%E8%AE%B0.assets/image-20211018155955357.png)

## 演示 带参数

- C语言：字符串

![image-20211018160810837](%E7%AC%94%E8%AE%B0.assets/image-20211018160810837.png)

- OC

![image-20211018170915910](%E7%AC%94%E8%AE%B0.assets/image-20211018170915910.png)

![image-20211018191502892](%E7%AC%94%E8%AE%B0.assets/image-20211018191502892.png)

桥接：把该OC语言变量交给该函数来管理（内存释放

**把OC对象传递给C语言的函数，要桥接**

# NSThread

## 演示1

![image-20211018193658934](%E7%AC%94%E8%AE%B0.assets/image-20211018193658934.png)

## 演示2

![image-20211018193853631](%E7%AC%94%E8%AE%B0.assets/image-20211018193853631.png)

## 演示3

![image-20211018193956883](%E7%AC%94%E8%AE%B0.assets/image-20211018193956883.png)

## 带参数的演示

![image-20211018194409569](%E7%AC%94%E8%AE%B0.assets/image-20211018194409569.png)

# 线程的状态

![image-20211018194955690](%E7%AC%94%E8%AE%B0.assets/image-20211018194955690.png)

- 阻塞会把线程对象 放出 可调度线程池中

阻塞状态结束后，会把线程对象 放进 调度线程池中

- 无法控制cup调度哪个线程, 执行到哪行再调度别的线程

第一个调度的线程未必是最先创建的线程

- 阻塞状态

```objective-c
- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    
    //新建状态
    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(demo) object:nil];
    //就绪状态
    [thread start];
}

- (void)demo{
    for (int i = 0; i < 20; i++) {
        NSLog(@"%d",i);
        
        if(i == 5){
            //阻塞状态
            [NSThread sleepForTimeInterval:3];
        }
        
        if(i == 10){
            //线程退出 死亡状态
            [NSThread exit];
        }
    }
}
```

- 一个线程结束之后，不能再次使用

- 系统有时候会自己创建辅助线程（不归自己管，也不用管，他会自己销毁

# 线程的属性/方法

- 给线程对象起名字

```objective-c
thread.name = @"t1";
```

- 判断当前线程是否是 主线程

![image-20211018201757480](%E7%AC%94%E8%AE%B0.assets/image-20211018201757480.png)

- 线程的优先级

![image-20211018202109215](%E7%AC%94%E8%AE%B0.assets/image-20211018202109215.png)

**无法 保证线程的第一优先级（第一个执行，该线程执行完毕再执行其他线程**

![image-20211018202158995](%E7%AC%94%E8%AE%B0.assets/image-20211018202158995.png)

# 多线程共享资源

![image-20211018214220359](%E7%AC%94%E8%AE%B0.assets/image-20211018214220359.png)

- 无法控制cup调度哪个线程, 执行到哪行 再调度别的线程

**所以线程（一般）是不安全的**

![image-20211018215921768](%E7%AC%94%E8%AE%B0.assets/image-20211018215921768.png)

解决：包装 读 写（不让别人插手

![image-20211018220139248](%E7%AC%94%E8%AE%B0.assets/image-20211018220139248.png)

# 互斥锁

- 原子操作

- 任意一个对象内部都有一个锁，默认锁是开着的

一个线程进去之后，就会把锁关了

这段代码执行完毕，锁就会打开

就盒上厕所 锁门一样

- 互斥锁为了实现 线程同步（按顺序，一个一个线程进行，中间不插队，一行行执行）

- 加锁会影响程序的性能，因为需要其他线程等待

- **@synchronized(self)**一般都这么写

![image-20211018222144428](%E7%AC%94%E8%AE%B0.assets/image-20211018222144428.png)

![image-20211018222321352](%E7%AC%94%E8%AE%B0.assets/image-20211018222321352.png)

# 原子属性

![image-20211018222532077](%E7%AC%94%E8%AE%B0.assets/image-20211018222532077.png)

- **自旋锁是原子属性**

- **原子属性特点：单写 多读**

- 原子属性（默认：atomic 线程安全

多个数据同时操作该变量，可以保证数据正确

- 里面加了 自旋锁：set方法加锁(保证单独写没问题，保证数值安全)

- **可以保证 单独 读/写 安全**

**无法保证 同时读写安全**

```objective-c
num = num - 1;
//num 写
//num - 1 对num读
//该语句就是同时读写
```



![image-20211018223236680](%E7%AC%94%E8%AE%B0.assets/image-20211018223236680.png)

# 互斥锁&自旋锁

![image-20211018224309097](%E7%AC%94%E8%AE%B0.assets/image-20211018224309097.png)

![image-20211018224609482](%E7%AC%94%E8%AE%B0.assets/image-20211018224609482.png)

# 异步下载网络图片

# strong&weak

![image-20211019104026387](%E7%AC%94%E8%AE%B0.assets/image-20211019104026387.png)

- 如果使用故事版创建控件，连线控件使用strong 

![image-20211019104344902](%E7%AC%94%E8%AE%B0.assets/image-20211019104344902.png)

那么就会有两个指针指向该控件

- 让一个类专门使用mrc

![image-20211019104741108](%E7%AC%94%E8%AE%B0.assets/image-20211019104741108.png)

## 自动释放池

![image-20211019110436695](%E7%AC%94%E8%AE%B0.assets/image-20211019110436695.png)



- 垃圾回收机制：在运行的时候

arc:在编译的时候

 ![image-20211019110739761](%E7%AC%94%E8%AE%B0.assets/image-20211019110739761.png)

- 使用自动释放池：

1、循环创建多个临时对象：**需要在循环里面创建自动释放池**

如果自动释放池添加到循环以外的话，循环很大的话，就会一直消耗内存直到循环结束

2、使用子线程 （不然会产生内存泄漏：该释放的没释放

原因：子线程无法使用主线程的自动释放池



野指针错误：不该释放的释放了

## 消息循环

- 按钮点击事件：基于消息循环

- 消息循环保证程序的持续运行:等着处理事件

![image-20211019112004210](%E7%AC%94%E8%AE%B0.assets/image-20211019112004210.png)

- app一旦运行（主线程）就会生成自动释放池

一个事件完成，自动释放池就会被销毁

# 属性修饰符

![image-20211019152807859](%E7%AC%94%E8%AE%B0.assets/image-20211019152807859.png)

Retain strong 一对相似功能

Weak ass

## 字符串

- 字符串,block用copy

## 三种block

- 忘记block

![image-20211019144125026](%E7%AC%94%E8%AE%B0.assets/image-20211019144125026.png)

- 打印block名字，就是打印它的类型

- 全局blcok：__ NSGlobalBlock __：

存储在代码区（本质是函数

![image-20211019144544011](%E7%AC%94%E8%AE%B0.assets/image-20211019144544011.png)

- mrc下：__ NSStackBlock __

存储在栈

block内部访问外部变量

![image-20211019144709257](%E7%AC%94%E8%AE%B0.assets/image-20211019144709257.png)

- mac下： __ NSMallocBlock __

存储在堆

![image-20211019145009099](%E7%AC%94%E8%AE%B0.assets/image-20211019145009099.png)

- arc下，第二种栈block存储在堆

**block作为属性：使用copy**

## delegate

 控制器--->person--->delegate---->self（控制器

   控制器强引用person：person在控制器里用strong

   person强引用delegate:属性用strong

   delegate强引用控制器：self.person.delegate = self;

   造成了循环引用

## strong

谁需要强引用，谁用strong

## weak&assign

- 同：都不是强引用

Weak ARC:**修饰对象**，不需要强引用

assign ARC/MRC：用于非指针变量。用于**修饰基础数据类型**（例如NSInteger）和c数据类型（int，float，double，char）另外还有id，反正记住：前面不加"*（星）"的就用assign吧

不需要强引用

- Objective-C 对象存储在堆上

NSObject *obj = [[NSObject alloc] init];
这行代码创建了一个 NSObject 类型的指针 obj 和一个 NSObject 类型的对象，obj 指针（存储对象的地址）存储在栈上，而其指向的对象则存储在堆上（简称为堆对象）。

- 为什么不能用assign修饰对象？

![image-20211019154726686](%E7%AC%94%E8%AE%B0.assets/image-20211019154726686.png)

1、用weak修饰对象：

执行第二句代码：因为没有强指针指向对象，所以对象一创建就会被销毁

通过指针weakPerson写name属性数据时，因为对象被销毁，会自动指向一个空对象（地址是0）

![image-20211019154856933](%E7%AC%94%E8%AE%B0.assets/image-20211019154856933.png)

2、用assign修饰对象：

执行第二句代码：因为没有强指针指向对象，所以对象一创建就会被销毁

通过指针weakPerson写name属性数据时，对象被销毁

但是不会自动指向一个空对象，所以发生野指针错误（释放了不应该释放的内存）

