#  消息循环NSRunloop

![image-20211019203000121](%E7%AC%94%E8%AE%B0.assets/image-20211019203000121.png)

- `NSRunloop`就是消息循环:`NSRunloop`是一个类 
- 主线程的消息循环默认开启，并创建自动释放池

![image-20211019203645542](%E7%AC%94%E8%AE%B0.assets/image-20211019203645542.png)

- 在循环的过程中，执行输入事件对应的方法

执行输入事件由消息循环模式决定

## 消息循环模式

- 消息循环模式默认 NSDefaultRunLoopMode

- 输入事件也需要指定一个模式

- 当前消息循环的模式  输入事件的消息循环模式 两者匹配才会执行![image-20211019220220676](%E7%AC%94%E8%AE%B0.assets/image-20211019220220676.png)

![image-20211019220346677](%E7%AC%94%E8%AE%B0.assets/image-20211019220346677.png)

![image-20211019220511269](%E7%AC%94%E8%AE%B0.assets/image-20211019220511269.png)



## 子线程的消息循环

![image-20211019220953454](%E7%AC%94%E8%AE%B0.assets/image-20211019220953454.png)

- 子线程的消息循环开启后，不会自动销毁

可以设置结束时间 run untildate 

- run开启子线程的消息循环前，必须在子线程的消息循环里面 加入输入事件

- 子线程的消息循环开启后，会创建自动释放池

# GCD

![image-20211019223947315](%E7%AC%94%E8%AE%B0.assets/image-20211019223947315.png)

- 一个框架

![image-20211019224107527](%E7%AC%94%E8%AE%B0.assets/image-20211019224107527.png)

- 任务：方法

- GCD使用线程池：

一个任务完成之后，该线程就放在线程池

此时如果有其他任务，线程池直接拿现有的线程用

如果一段时间过去，没有新的任务，线程池就会把其中的线程销毁

![image-20211019225938713](%E7%AC%94%E8%AE%B0.assets/image-20211019225938713.png)

![image-20211019232448799](%E7%AC%94%E8%AE%B0.assets/image-20211019232448799.png)

![image-20211019232530556](%E7%AC%94%E8%AE%B0.assets/image-20211019232530556.png)

- 队列的类型：并发/串行 针对于队列的任务分的

![image-20211019232729129](%E7%AC%94%E8%AE%B0.assets/image-20211019232729129.png)



- 执行方式：同步/异步

# 异步下载网络图片

# 四种队列

## 串行队列

![image-20211019233107642](%E7%AC%94%E8%AE%B0.assets/image-20211019233107642.png)

## 并行队列/并发队列

![image-20211020084746248](%E7%AC%94%E8%AE%B0.assets/image-20211020084746248.png)

## 主队列（全局串行队列

![image-20211020084729501](%E7%AC%94%E8%AE%B0.assets/image-20211020084729501.png)

- 先执行主线程上的代码，才会执行队列中的任务

- 主队列（全局串行队列：

串行：主队列在主线程执行

全局：主线程不会释放

### 主队列&串行队列

![image-20211020093237724](%E7%AC%94%E8%AE%B0.assets/image-20211020093237724.png)

 ## 全局（并行）队列

![image-20211020151003716](%E7%AC%94%E8%AE%B0.assets/image-20211020151003716.png)

- 全局队列一直存在，只有一个**无论ARC/MRC都不需要释放**

- **一般使用全局队列**

```objective-c
//获取全局队列
dispatch_get_global_queue(0, 0);
//第一个参数 优先级
//QOS_CLASS_USER_INTERACTIVE（用户交互，优先级最高）, QOS_CLASS_USER_INITIATED, QOS_CLASS_UTILITY, or QOS_CLASS_BACKGROUND. 
//第二个参数：写0
```

- MRC：并发队列（由C语言creat,copy创建需要release)

![image-20211020152121200](%E7%AC%94%E8%AE%B0.assets/image-20211020152121200.png)

# 同步任务

![image-20211020153111716](%E7%AC%94%E8%AE%B0.assets/image-20211020153111716.png)

# 队列的执行效果

![image-20211020155037935](%E7%AC%94%E8%AE%B0.assets/image-20211020155037935.png)

![image-20211020155838666](%E7%AC%94%E8%AE%B0.assets/image-20211020155838666.png)

![image-20211020160125594](%E7%AC%94%E8%AE%B0.assets/image-20211020160125594.png)

# barrier阻塞

![image-20211020160957081](%E7%AC%94%E8%AE%B0.assets/image-20211020160957081.png)

- 用来多线程里面 操作可变数组
- 多线程中，mutable类 需要加锁/阻塞

# GCD其他操作

## 延迟操作

![image-20211020194836027](%E7%AC%94%E8%AE%B0.assets/image-20211020194836027.png)

## 一次性执行

**一次执行是线程安全的**

```objective-c
    //无论放在哪里都只执行一次
    //执行在当前线程里面
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        for (int i = 0; i < 300; i++) {
            static dispatch_once_t onceToken;
                      //静态全局变量，初始0，来控制block内只执行一次
            dispatch_once(&onceToken, ^{
                NSLog(@"once111111%@",[NSThread currentThread]);
            });
        }
    });
   
    for (int i = 0; i < 300; i++) {
        static dispatch_once_t onceToken;
        dispatch_once(&onceToken, ^{
            NSLog(@"once222222222%@",[NSThread currentThread]);
        });
    }
```

- 工具类：常用的类，只在一个项目中存在一份（单例）就够了

## 单例

**单例：一个类，只会有一个对象(整个程序里）**

是常有的对象

- 单例的类方法以default / shared 开头
- 静态变量存储在静态区，只有整个程序结束才会释放

```objective-c
//单例类 类方法
+ (instancetype)sharedMyToolsOnce{
    static id instance = nil;
    
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        if (instance == nil) {
            instance = [[self alloc] init];
        }
    });
    return instance;
}
```

## 调度组

![image-20211020213909659](%E7%AC%94%E8%AE%B0.assets/image-20211020213909659.png)

![image-20211020215134052](%E7%AC%94%E8%AE%B0.assets/image-20211020215134052.png)

- dispatch_group_async

内部原理：

![image-20211020215917725](%E7%AC%94%E8%AE%B0.assets/image-20211020215917725.png)

计数为0，就可以通知了

MRC需要release

# NSOperation

![image-20211020221807058](%E7%AC%94%E8%AE%B0.assets/image-20211020221807058.png)

![image-20211020222649587](%E7%AC%94%E8%AE%B0.assets/image-20211020222649587.png)

- 抽象类，没有实现，使用：用作父类（约束子类）

- 使用：队列，操作（类似GCD的任务）

- **用NSOperation就是为了开 异步执行 新线程**

![image-20211020223114722](%E7%AC%94%E8%AE%B0.assets/image-20211020223114722.png)

- 先进先出

## NSInvocationOperation

- 是NSOperation的子类

- 每一个线程都有一个main方法

## NSBlockOperation

![image-20211020225127494](%E7%AC%94%E8%AE%B0.assets/image-20211020225127494.png)

## NSOperationQueue

![image-20211020233300125](%E7%AC%94%E8%AE%B0.assets/image-20211020233300125.png)

# 线程间通信

![image-20211020233513568](%E7%AC%94%E8%AE%B0.assets/image-20211020233513568.png)

