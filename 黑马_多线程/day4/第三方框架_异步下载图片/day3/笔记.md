#   NSOperation & GCD

![image-20211021144342865](%E7%AC%94%E8%AE%B0.assets/image-20211021144342865.png)

# NSOperation（它队列的方法，属性）

- **会不停地开新的线程，无法自动重用**

- 操作执行完之后，会从队列中移除

## 最大并发数

![image-20211021144811347](%E7%AC%94%E8%AE%B0.assets/image-20211021144811347.png)

- 并发数 ！= 线程数

并发数3，有可能有1，2个线程处于就绪状态

- **会不停地开新的线程，无法自动重用**

这样效率不高，所以需要设置最大并发数控制 线程数

## 队列的暂停/取消/恢复

![image-20211021150418228](%E7%AC%94%E8%AE%B0.assets/image-20211021150418228.png)

# 摇奖机

## 操作的优先级

- 操作在队列中的优先级

![image-20211021163426778](%E7%AC%94%E8%AE%B0.assets/image-20211021163426778.png)

**无法保证绝对的执行顺序**

## 监听操作完成（回调）

![image-20211021164444854](%E7%AC%94%E8%AE%B0.assets/image-20211021164444854.png)

## 操作依赖

![image-20211021165313146](%E7%AC%94%E8%AE%B0.assets/image-20211021165313146.png)

- 操作依赖：一个操作等到另一个操作完成后 才能执行

**依赖关系可以跨队列执行**

# 异步下载网络图片

![image-20211021172712081](%E7%AC%94%E8%AE%B0.assets/image-20211021172712081.png)

遍历推荐，多了索引/键值对

- 控件都是懒加载

- 单元格return之前，点击/滚动，调用cell的layoutSubviews（设置单元格内控件的frame）

## 占位图片

- 为了避免异步加载图片 的显示问题

- 先在主线程设置占位图片（让系统调用cell的layoutSubviews，设置图片frame)

## 缓存图片

![image-20211021230109344](%E7%AC%94%E8%AE%B0.assets/image-20211021230109344.png)

## 单元格重用问题

![image-20211021233936302](%E7%AC%94%E8%AE%B0.assets/image-20211021233936302.png)

## 图片缓存池

- 缓存池：数组/字典：可以存储多个对象

- 当收到内存警告，要清理内存

如果图片存储在模型对象中，不好清理内存

  //图片的缓存池

![image-20211023140152718](%E7%AC%94%E8%AE%B0.assets/image-20211023140152718.png)

## 操作缓存池

上下滚动，重复下载图片，浪费流量问题

![image-20211022224558696](%E7%AC%94%E8%AE%B0.assets/image-20211022224558696.png)

避免图片在快速滚动中 多次创建

## block

- **block里面有self就要担心循环引用问题**

一般解决方式：
![image-20211023213147391](%E7%AC%94%E8%AE%B0.assets/image-20211023213147391.png)

```objective-c
__weak typeof(self) weakSelf = self;
/*
typeof(self)获取self的类型；
typeof(self)weakSelf 定义一个self类型的变量;
typeof(self)weakSelf = self 将self赋值给typeof(self)weakSelf的变量；
__weak typeof(self)weakSelf = self 将该变量置为弱引用类型。
*/
```



![image-20211023211105183](%E7%AC%94%E8%AE%B0.assets/image-20211023211105183.png)

- 操作完成后，会从队列中移除，所以引动里面保留queue对操作的引用，移除downloadCach

downloadCach为了避免 同时重复下载，所以在下载完成后 在操作缓存池中移除 之前下载好的操作

- block容易引起循环引用是因为在VC中声明block，VC拥有block，在block中访问self，block拥有self，所以会造成循环引用

## 操作mutable线程不安全

# Dynamic Prototype动态原形cell

![image-20211023214843635](%E7%AC%94%E8%AE%B0.assets/image-20211023214843635.png)

- 一个可自定义cell模版

- 绑定自定义tableViewCell, 绑定identifier

## 无网络无限下载

图片是nil

![image-20211024214025322](%E7%AC%94%E8%AE%B0.assets/image-20211024214025322.png)

# @class&#import

.接下来说说什么时候该用@class，什么时候该用#import进行声明，

 (1)一般如果有继承关系的用#import，如Ｂ是Ａ的子类那么在Ｂ中声明Ａ时用#import

 (2) 另外就是如果有循环依赖关系，如：A->B,B->A这样相互依赖时，如果在两个文件的头文件中用#import分别声明对方，那么就会出现头文件循环利用的错误，这时在头文件中用@class声明就不会出错

 (3)还有就是自定义代理的时候，如果在头文件中想声明代理的话如@interface SecondViewController:UIViewController时应用#import不然的话会出错误，注意ＸＸＸＸDelegate是自定义的

https://www.cnblogs.com/wangpei/p/3403733.html

# 沙盒缓存

![image-20211024224617103](%E7%AC%94%E8%AE%B0.assets/image-20211024224617103.png)

![image-20211024225005609](%E7%AC%94%E8%AE%B0.assets/image-20211024225005609.png)

内存速度〈  沙盒速度 

![image-20211024234257634](%E7%AC%94%E8%AE%B0.assets/image-20211024234257634.png)

