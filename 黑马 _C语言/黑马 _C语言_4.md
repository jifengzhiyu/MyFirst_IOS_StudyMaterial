

# 字符串

- 字符串数据需要用双引号

```c
"Cathy"
```

- 使用字符数组来存储一个个字符：

```c
char name[5];
name[0] = 'C';
name[1] = 'a';
name[2] = 't';
name[3] = 'h';
name[4] = 'y';
```

- 储存字符串：

将字符串数据的每一个字符储存到字符数组中，在后边追加一个**'\0'**代表字符串储存完毕

![image-20210727191730864](%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210727191730864.png)

```c
1、根本方法
  char name[5] = {'j','a','c','k','\0'};
char name[] = {'j','a','c','k','\0'};
2、简写方式
  char name[] = {"jack"};
//系统会自动将字符串中的每一个字符储存到字符数组中，并自动追加'\0'
3、最常用
  char name[] = "jack";
```

- 字符数组的长度：

如果没有指定字符数组的长度：字符串的长度+1（\0）

如果指定了，长度就是指定的长度，剩余的就是全是\0

就别指定长度了 

```c
//如果在声明1个字符数组的同时就初始化字符数据给数组的时候可以用中文
char name[] = "开心";
//一个中文3个字符
```

- 打印字符数组

格式控制符%s，就可以输出存在字符数组的字符串数据

从给定的数组开始，一个一个字符输出，直到遇到\0截止

```c
char name[] = "jack";
printf("%s",name);//不需要取地址符，本来就是地址
```

![image-20210727193646224](%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210727193646224.png)

输出str1,2，直到遇到\0

- 输入字符串

```c
//1、准备一个字符数组来保存输入的字符串
char str[10];//给的空间适量
//2、scanf
scanf("%s",str);//不用取地址符
//输入空格，就代表输入结束
```

所以用scanf不安全：字符数组超过存储会报错；输入空格，就代表输入结束

- 计算数组中存储的字符串的长度

![image-20210727195018164](%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210727195018164.png)

正确：从第一个字节开始计数，直到遇到\0

```c
char name[100] = "jack";
int len = 0;
while（name[len] ！= '\0'）{
  len++;
}
```

# 字符串常用函数

- Puts()用来输出字符串

```c
puts（字符数组名）；
char name[] = "jack";
puts(name);
```

优点：自动换行

缺点：只能输出字符串，不能使用占位符

- Gets()用来输入字符串

```c
gets(字符数组名）；
char name[10];
gets(name);
```

优点：可以接收空格

缺点：不安全，存不下就报错

------------------------------------------------------------

下面的函数在string.h文件中

- **strlen()得到储存在字符数组中字符串的长度**

```c
strlen(函数名）；
unsigned long len = strlen(name);
```

- **Strcmp()比较两个字符串的大小**

Compare 

```c
tsrcmp(字符串1，字符串2）;
char name1[] = "aaaaaa";
char name2[] = "bbb";
int res = strcmp(name1,name2);
```

若返回值是负数，字符串1比字符串2小

若返回值是正数，字符串1比字符串2大

若返回值是0，就说明一样大

比较规则：比的是相同位置的字符的ASK II码的大小,从第一个比起，如果一样大就比双方的第二位

- Strcpy()把存储在一个字符串数组中的字符串数据拷贝在另外一个字符数组中存储

````c
strcpy(字符数组1,字符数组2);
char name1[] = "aaaaaa";
char name2[] = "bbb";
strcpy(name1,name2);
//把name2拷贝到name1里面
printf("%s\n%s\n",name1,name2);
//只是拷贝，name2里面的字符串不变
````

问题：存储字符串1的字符数组长度不够，无法存储字符串2，会崩溃

- Strcat()把存储在字符串数组2的字符串数据连接在字符串1后面(连接的时候会把字符串1的‘\0’删除)

Contact 连接

```c
stract（字符数组1，字符数组2）；
char name1[10] = "aaaaaa";
char name2[] = "bbb";
strcat(name1,name2);
 //将两个字符串合成一个字符串
//只是连接，name2里面的字符串不变
```

问题：如果字符数组1无法储存字符数组2的字符串数据，就会崩溃

# 走出迷宫

```c
#include <stdio.h>
#include<stdlib.h>
#define ROWS 6
#define COLS 8
/*
 游戏的流程：
 1、根据map二维数组，显示游戏地图
 while(1){
 2、接收用户输入小人的前进方向
 3、判断方向，移动小人
 }
 */
//1、创建一个二维数组来保存迷宫

 char map[ROWS][COLS] = {
     {'#','#','#','#','#','#','#','#'},
     {'#','o','#','#',' ',' ',' ','#'},
     {'#',' ','#','#',' ','#',' ','#'},
     {'#',' ',' ','#',' ','#',' ','#'},
     {'#','#',' ',' ',' ','#',' ','#'},
     {'#','#','#','#','#','#',' ','#'}
 };

//保存小人的行坐标
int personCurrentRow = 1;
//保存小人的列坐标
int personCurrentCol = 1;

/// 根据map打印地图
void showMap(void);
/// 接收用户输入小人的前进方向
char enterDirection(void);
///将小人向上移动
void moveToUp(void);
///将小人向下移动
void moveToDown(void);
///将小人向左移动
void moveToLeft(void);
///将小人向右移动
void moveToRight(void);

int main (int argc,const char * argv[]){
    //2、打印地图，地图是一个经常会用到的功能，把它单独封装一下
    while(1){
    //将屏幕上所有显示信息清空
    system("clear");
    showMap();
    //3、接收用户输入小人的前进方向,独立功能，封装函数
    char dir = enterDirection();
    //判断方向，移动小人,独立功能，封装函数
    switch(dir){
        case'a':
        case'A':
            // 将小人向左移动
            moveToLeft();
            break;
        case'd':
        case'D':
            //将小人向右移动
            moveToRight();
            break;
        case'w':
        case'W':
            //将小人向上移动
            moveToUp();
            break;
        case's':
        case'S':
            //将小人向下移动
            moveToDown();
            break;
        case'q':
        case'Q':
            //结束游戏
            printf("少年，你的智商真低\n");
            return 0;//先不管这个
            break ;
    }
        if(personCurrentRow == 5){
            if(personCurrentCol == 6){
                printf("你的智商没问题\n");
                break;
    }
        }
    }
    
    return 0;
}


/// 根据map打印地图
void showMap(){
    for(int i = 0;i < ROWS;i++){
        for(int j = 0;j < COLS;j++){
            printf("%c ",map[i][j]);
        }
        printf("\n");
    }
}


/// 接收用户输入小人的前进方向
char enterDirection(){
    //1、输入前进方向
    printf("请输入小人前进方向：w.上 s.下 a.左 d.右 q.结束游戏");
    //2、接收
    char dir = 'a';
    rewind(stdin);
    scanf("%c",&dir);
    return dir;
}

///将小人向上移动
void moveToUp(void)
{
    //1、得到小人的下一个坐标
    int personNextRow = personCurrentRow - 1;
    int personNextCol = personCurrentCol;
    //2 、判断上面格子的类型，是否可以移动
    if(map[personNextRow][personNextCol] == ' '){
        //3、为下一个格子赋值o，小人当前位置' '
        map[personNextRow][personNextCol] = 'o';
        map[personCurrentRow][personCurrentCol] = ' ';
        //4、修改小人当前的位置
        personCurrentRow = personNextRow;
        personCurrentCol = personNextCol;
    }
}
///将小人向下移动
void moveToDown(void)
{
    //1、得到小人的下一个坐标
    int personNextRow = personCurrentRow + 1;
    int personNextCol = personCurrentCol;
    //2 、判断下面格子的类型，是否可以移动
    if(map[personNextRow][personNextCol] == ' '){
        //3、为下一个格子赋值o，小人当前位置' '
        map[personNextRow][personNextCol] = 'o';
        map[personCurrentRow][personCurrentCol] = ' ';
        //4、修改小人当前的位置
        personCurrentRow = personNextRow;
        personCurrentCol = personNextCol;
    }
    
}
///将小人向左移动
void moveToLeft(void){
    //1、得到小人的下一个坐标
    int personNextRow = personCurrentRow;
    int personNextCol = personCurrentCol - 1;
    //2 、判断下面格子的类型，是否可以移动
    if(map[personNextRow][personNextCol] == ' '){
        //3、为左一个格子赋值o，小人当前位置' '
        map[personNextRow][personNextCol] = 'o';
        map[personCurrentRow][personCurrentCol] = ' ';
        //4、修改小人当前的位置
        personCurrentRow = personNextRow;
        personCurrentCol = personNextCol;
    }
}
///将小人向右移动
void moveToRight(void){
    //1、得到小人的右一个坐标
    int personNextRow = personCurrentRow;
    int personNextCol = personCurrentCol + 1;
    //2 、判断下面格子的类型，是否可以移动
    if(map[personNextRow][personNextCol] == ' '){
        //3、为下一个格子赋值o，小人当前位置' '
        map[personNextRow][personNextCol] = 'o';
        map[personCurrentRow][personCurrentCol] = ' ';
        //4、修改小人当前的位置
        personCurrentRow = personNextRow;
        personCurrentCol = personNextCol;
    }
}
```

# 变量值与地址

- 指针是C语言的灵魂

- 内存中储存数据最小基本单位是字节，每一个字节都有一个内存地址

声明一个变量，在内存中从高地址到低地址连续分配相应字节空间（变量是空间）

- 变量的值：存储在变量中的数据

- 变量的地址：组成这个变量低字节的地址

变量的地址就叫做指针

# 指针变量

- 指针变量pointer：存储指针数据（地址）

一个指针变量的值是哪一个变量的地址，就说指针变量指向那个一变量

- 访问变量的方式

1、直接访问

2、间接访问：通过指针变量间接访问（指针变量指向的）变量

- 指针变量的声明

```c
数据类型* 指针变量名；
int* p1;
//声明一个指针变量，指针变量的名字是p1，指针变量的类型是int*，读作int指针
```

指针的类型：有哪些普通的类型就可以有哪些指针的类型double* p2;

*的位置

```c
int* p1;//建议
int * p1;
int *p1;
//p1指针变量只能存储int普通变量的地址
```

只能存储和这个指针类型相同的 普通变量的地址

- 指针变量的初始化:取地址符&

```c
int num = 10;
int* p1 = &num;
printf("%p\n",&num);
printf("%p\n",p1)//p1是地址，用%p打印
  //p1指针变量的值是num的地址，p1指针指向num变量
  printe("%p",&p1);//p1指针的地址
```

![image-20210728174526923](%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210728174526923.png)

```c
指针指向的变量:*指针变量名；
int num = 10;
int* p1 = &num;
//*p1就是num
 *p1 = 100;//num =  100;
printf("%d\n",*p1);
// printf("%d",num);
```

```c
int* p1,p2,p3;
//只要p1是指针，p2,p3是int类型的普通变量
int* p1,*p2,*p3;
//三个都是指针变量
```

- 野指针：如果没有对指针变量初始化，指针变量的值就是垃圾值，指向随机空间

![image-20210728181143136](%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210728181143136.png)

# NULL值

- 初始指针变量：NULL：这个指针变量不指向任何变量（推荐）

也可以赋值0

NULL和0等价

```c
int* p1 = NULL;
或
int* p1 = 0;
printf("%d\n",*p1);
```

- 多个指针指向同一个变量

```c
int num = 10;
int* p1 = &num;
int* p2 = p1;
*p1 = 100;
printf("%d\n",*p2);//打印100

```

![image-20210728182453384](%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210728182453384.png)

# 指针作为函数的参数

- 函数的参数是int,char,double,float时，参数的传递是值传递，在函数内部修改形参变量的值，对实参没有任何影响

函数的参数是数组时，参数的传递是地址传递，在函数内部修改形参数组的值，就是在修改实参数组的值

函数的参数是指针时，传递一个和指针类型相同的普通变量的地址,在函数内访问参数指针变量就是在访问实参变量

```c
void test(int*p1){
  *p1 = 1000;
}
int main(){
int num = 10;
  test(&num);
  printf("%d",num);
  return 0;
}
```

![image-20210728183811576](%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210728183811576.png)

- 指针作为函数参数的效果：地址的传递（所以说数组是特殊的指针）

1、函数的内部可以修改实参变量的值

1）函数只能返回一个数据，指针作为函数参数可以**返回多个数据**

```c
/// 返回一个整形数组中的最大值，最小值
int getMaxAndMin(int arr[],int len,int* min){
    int max = INT32_MIN;
    *min = INT32_MAX;
    for(int i =  0;i < len;i++){
        if(arr[i] > max){
            max = arr[i];
        }
        if(arr[i] < *min){
            *min = arr[i];
        }
    }
    return max;
}


int main(){
    int arr[] = {123,34,3,35,34,5456,4,23,2,4,23,5,12};
    int min = 0;
    int max = getMaxAndMin(arr, sizeof(arr)/sizeof(arr[0]), &min);
    printf("min = %d\nmax = %d\n",min,max);
    return 0;
}
```

如果最大值和最小值都要指针作为参数的话

```c
void getMaxAndMin(int arr[],int len,int* pMax,int* pMin){
int max = INT32_MIN;
int min = INT32_MAX;
for(int i = 0;i < len;i++){
    if(arr[i] > max){
        max = arr[i];
    }
    if(arr[i] < min){
        min = arr[i];
    }
}
    *pMax = max;
    *pMin = min;
}
int main(){
    int arr[] = {23,345,43,64,6,5,675,68,3,4543,6};
    int max = 0;
    int min = 0;
    getMaxAndMin(arr, sizeof(arr)/sizeof(arr[0]), &max, &min);
    printf("max = %d\nmin = %d\n",max,min);
    return 0;
}
```

# 指针分类型

- 指针变量都是8个字节
- 通过指针间接访问普通变量

一个指针变量只是找到变量低字节（一个字节）的地址，通过指针操作多少字节根据指针的类型决定

指针变量的类型决定了，通过这个指针找到字节以后，连续操作多少个字节空间 

Int* 会操作4个字节

- 指针的类型如果不和指向变量的类型相同的话，就无法通过指针完全访问指向变量的值

所以指针变量一定要指向一个和自己类型相同的普通变量

# 多级指针

- 一级指针：1个指针变量中储存1个普通变量的地址

```c
int mun = 10;
int* p1 = &num;
printf("num变量的地址是：%p\n",&num);
printf("p1指针的值是：p1 = %p\n",p1);
printf("p1指针的地址是：%p\n",&p1);
```

二级指针：1个指针变量中存储的是1个一级指针变量的地址

```c
声明：数据类型** 指针名；
  int** p2 = &p1;
printf("p2指针的值是：p2 = %p\n",p2);
printf("p2指针的地址是：%p\n",&p2); 
```

三级指针：1个指针变量中存储的是1个二级指针变量的地址

```c
声明：数据类型*** 指针名；
  int*** p3 = &p2;
```

- n级指针:

**只能存储n-1级指针的地址**

**使用指针间接访问指向的变量的时候，有几颗星就拐几次弯**

# 二级指针的使用

![image-20210728203818085](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210728203818085.png)

- **p2：p2指针所指向指针所指向的变量

![image-20210728205007937](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210728205007937.png)

![image-20210728205149092](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210728205149092.png)

# 指针与整数的加减法

- 指针与整数进行加减运算：

在指针地址的基础上加/减一个单位变量占用的字节数

![image-20210728205811086](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210728205811086.png)

```c
int num1 = 10;
int num2 = 20;
int* p1 = &num2;
p1++;
printf("*p1 = %d\n",*p1);
//指针一开始指向num2，之后指向num1
```

![image-20210728210212197](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210728210212197.png)

# 指针与数组

![image-20210728210359043](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210728210359043.png)

- 指针变量指向数组的元素，通过指针操作数组的元素

```c
int arr[3] = {10,20,30};
int* p0 = &arr[0];
int* p1 = &arr[1];
int* p2 = &arr[2];
*p0 = 100;
*p2 = 200;
*p3 = 300;
for(int i = 0;i< 3;i++){
  printf("%d",arr[i]);
}
```

```c
int* p1 = &arr[0];
等价于
int* p1 = arr;//数组名就是数组第0个元素的地址
```

```c
//使用指针遍历数组的方式
int arr[7] = {10,20,30,40,50};
int* p1 = arr;
for(int i = 0;i < 7;i++){
  printf("%d\n",*(p1+i));
  //或者
  //  printf("%d\n",*(arr+i));
  //  printd("%d\n",*(p1++));这种方法会改变p1所指的变量，不适合重复使用，此时需要把p1的值托管在一个中间变量 或 遍历之后重新把arr赋值给指针的地址
}
```

- p1+1：给p1加一个单位变量占用的字节数，p1+1就成了下一个元素的地址，*(p1+1)就是下一个元素
- 数组名代表数组的地址，数组一旦确定就不能改变数组的地址，所以不能修改数组名的值，数组的地址

无法修改数组名的值（数组名代表数组的地址）

# 数组作为参数的本质

- 在声明参数数组的时候，不是创建数组，是在创建1个用来存储地址的**指针变量** 

最后这么写

```c
void test(int* arr,int len);
```

# 索引的本质

- 指针变量后面可以使用中括弧，写上下标访问数据

p1[n]；前提是p1是一个指针变量

等价于*(p1+n);

```c
int num1 = 10;
int num2 = 20;
int* p1 = &num2;
p1[0] = 1000;//*(p1+0); *p1;
printf("num2 = %d\n",num2);
p1[1] = 2000;//*(p1+1); num1;
printf("num1 = %d\n",num1);
```

- 只要是指针都可以用索引

```c
int arr[5] = {10,20,30,40,50};
*arr = 100;
printf("arr[0] = %d\n",arr[0]);
arr[0] = 1000;//*(arr+0) = 1000;数组名是数组低字节的地址，是指针
arr[1] = 200;//*(arr+1) = 200;
```

操作数组虽然用中括弧下标来操作，实际上内部是用指针来操作

# 取值运算符 *

- *后面可以跟指针

也可以是结果为指针的表达式

*(p1+1);

![image-20210728224006300](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210728224006300.png)

# 存储指针的数组

```c
元素类型 数组名 【数组长度】；
int* arr[3];
//数组的元素类型是int指针
int num1 = 10,num2 = 20,num3 = 30;
int* p1 = &num1,*p2 = &num2,*p3 = &num3;
int* arr[3] = {p1,p2,p3};//int* arr[3] = {&num1,&num2,&num3};
for(int i = 0;i < 3;i++){
  printf("arr[%d] = %p\n",i,arr[i]);
}
```

```c
int arr[3] = {10,20,30};
int* pArr[3] = {arr,&arr[1],&arr[2]};
//pArr数组的元素是arr数组元素的指针
*(pArr[0]) = 100;
//arr[0] = 100;
int num = 1000;
pArr[1] = &num;
//&arr[1] = &num;原来pArr[1]指向arr第一个元素，现在pArr[1]指向num变量
*(pArr[1]) = 2000;
//*(&num) = 2000; num = 2000;
```

# 指针与指针的减法

- 指针与指针的减法，两个指针指向的变量之间相差多少个单位变量

结果是long类型

**用来判断数组的两个元素之间相差多少个元素**

```c
int arr[5] = {10,20,30,40,50};
int* p1 = &arr[1];
int* p2 = &arr[4];
long res = p2 - p1;
printf("res = %ld\n",res);//3
```

- 参与运算的两个指针必须指向同一个数组

- 指针与指针的减法，算出两个指针所指变量之间隔了多少地址，再将其除以指针变量对应普通变量占用的字节数

Int* p就除以4

- 指针与指针之间只能做减法运算

# 指针与指针之间的比较运算

![image-20210729103117483](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210729103117483.png)

```c
int num1 = 10;//高地址
int num2 = 20;//低地址
int* p1 = &num1;
int* p2 = &num2;
int res = p1 > p2;//比较的是p1与p2的值
printf("res = %d\n",res);
```

- 判断两个指针指向变量的地址，哪个在高地址，哪个在低地址（等等）

- 也可以用==,!=判断两个指针指向的变量是不是同一个变量

# 指针和字符串

- 指针和字符变量

```c
char ch = 'a';
char* p1 = &ch;
*p1 = 'b';
printf("ch = %c\n",ch)//b
```

- 指针和字符数组

```c
char chs[4] = {'a','b','c','d'};
char* p1 = chs;//p1指向chs数组的第0个元素
*p1 = 'x';
for(int i = 10;i<4;i++){
  printf("%c\n",*(p1+i));
  //printf("%c\n",*(chs+i));
}
```

![image-20210729120340791](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210729120340791.png)

- 字符串数据在C语言中的储存

1、使用字符数组储存

```c
char name[] = "jack";
```

2、使用字符指针来储存

将字符串数据初始化给一个字符指针

```c
char* name = 'jack';
printf("name = %s\n",name);//一般来说需要*取值符，但是它就是这样，不用取值符
```

![image-20210729120739403](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210729120739403-7532699.png)

3、区别：

![image-20210729153621072](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210729153621072.png)

![image-20210729153638774](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210729153638774.png)

name1可以更改name2无法更改

```c
char name1[] = "jack";
char* name2[] = "rose";
```

若name1,2是局部变量时：

1、name1字符数组存在栈里，字符串数据存储在栈里

2、name2指针变量存在栈里，指针变量的值是字符串的在常量区的地址，字符串数据以字符数组的形式储存在常量区

![image-20210729151813310](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210729151813310.png)

若name1,2作为全局变量的时：

1、name1字符数组存储在常量区，字符串数据存储在常量区里

2、name2指针变量存储在常量区，字符串数据以字符数组形式存储在常量区，指针的值是字符串在常量区的地址

![image-20210729152817672](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210729152817672.png)

# 内存中的五大区域

：都是来存储数据，不同的数据存储在不同的区域

1、栈：专门存局部变量

2、堆：允许手动申请指定空间使用

3、BSS段：未初始化的全局变量和静态变量（程序运行最开始时，变量没有初始化，初始化之后放在常量区）

4、数据段/常量区：已经初始化的全局变量，静态变量。常量

5、代码块：程序的代码/指令

- 建议使用**字符指针存储字符串的数据**

好处：字符数组长度固定，字符指针长度任意

# 字符串的恒定性

- 前提：**以字符指针形式存储的字符串**
- 表现：

1、字符串数据存储在常量区。一旦存储到常量区，就无法通 过指针修改字符串数据

2、将字符串数组存储到常量区之前，检查常量区是否有相同内容的字符串，如果有将地址拿来用，否则才会把字符串数组存储在常量区

![image-20210729154902006](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210729154902006.png)

3、当**重新**为字符指针初始化1个字符串的时候，没有修改原来的字符串，而是重新创建一个字符串，把新字符串的地址赋值给它

![image-20210729155535608](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210729155535608.png)

- 一个题

```c
//求一个字符串里面字符'e'出现的次数
//1、声明一个整形的变量计数
//2、遍历每一个字符，判断是不是'e'，是的话计数器++
int main(){
    char* str = "sdasfeasdsacfesadascfedsdasdaseedasedeasee";
    int count = 0;//计数器
    //通过指针找到字符串的第一个字符，直到'\0'
    int i = 0;
    while(*(str+i) != '\0'){
        if(*(str+i) == 'e'){
            count++;
        }
        i++;
    }
    
    /*while(str[i] != '\0'){  中括弧的本质str[i] == *(str+i)
     if(str[i] == 'e'){
         count++;
     }
     i++;
 }*/
    
    printf("count = %d\n",count);
    return 0;
}
```

# 存储字符串方式

- 1、使用二维字符数组，存多个字符串，一行就是一个字符串(字符数组)

每一个字符串的长度不能超过列数-1（'\0')

```c
int main(){
    char names[3][5] =
    {
        "jack","rose","lily"
    };
    for(int i = 0;i < 3;i++){//一行一行输出
        printf("%s\n",names[i]);
    }
    return 0;
}
/*
j a c k '\0'
r o s e '\0'
l i l i '\0'
*/
```

2、**使用字符指针数组**

每一个元素都是char指针类型

初始化给元素的字符串数组存储在常量区：比如第一个元素就是char* p1 = "jack";(以字符指针形式存储的字符串)

```c
char* names[4] = {"jack","rose","lily","lilei"};
for(int i = 0;i < 4;i++){
  printf("%s\n",names[1]);
}
```

![image-20210729163910178](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210729163910178.png)

好处：每一个字符串的长度没有限制

# 字符串数组的排序

- 按照字母顺序排序

1、冒泡排序

存储指针的数组每一个元素是指针，8个字节

```c
#include <string.h>

int main(){
    char* abaaba[] = {"dad","sdsdfdsfsdg","dsgdsgd","autgd","btvxcv"};
    int len = sizeof(abaaba) / sizeof(abaaba[0]);
    //使用冒泡排序,比较ASKII
    for(int i = 0;i < len - 1;i++){
        for(int j = 0;j < len - 1 - i;j++){
            int res = strcmp (abaaba[j],abaaba[j+1]);
            if(res > 0)//j大
            {
                char* temp = abaaba[j];
                abaaba[j] = abaaba[j+1];
                abaaba[j+1] = temp;
            }
        }
    }
    for(int i = 0;i < len;i++){
        printf("%s\n",abaaba[i]);
    }
    
    return 0;
}
```

- 按照字母长度排

```c
#include <string.h>

int main(){
    char* abaaba[] = {"dad","sdsdfdsfsdg","dsgdsgd","autgd","btvxcv"};
    int len = sizeof(abaaba) / sizeof(abaaba[0]);
    //使用选择排序,比较ASKII
    for(int i = 0;i < len - 1;i++){
        for(int j = i + 1;j < len ;j++){
            unsigned long len1 = strlen(abaaba[i]);
            unsigned long len2 = strlen(abaaba[j]);
            if(len1 > len2){
                char* temp = abaaba[i];
                abaaba[i] = abaaba[j];
                abaaba[j] = temp;
            }
        }
    }
    for(int i = 0;i < len;i++){
        printf("%s\n",abaaba[i]);
    }
    
    return 0;
}
```

# fputs

- Fputs();

将字符串数据输出到指定的流中

流：标准输出流---》控制台（printf)

​       文件流---------〉磁盘上的文件

- 标准输出流：控制台

```c
fputs(要输出的字符串，指定的流）；
标准输出流：控制台： .stdout
char* name = "饿了吗？";
fputs(name,stdout);
```

- 将字符串存储到文件中

1、声明文件指针，指向磁盘上的文件

```c
FILE* pFile = fopen();
fputs();//写入
fclose(pFile);//关闭文件
//fopen函数可以创建一个指向文件的指针,两个参数，第一个文件的路径，创建的指针指向这个文件，第二个参数，告诉对文件进行的操作："w"写入内容，"r"读取数据，"a"追加数据（apped)
FILE* pFile = fopen("/Users/kaixin/Documents/my_github/C-notes/ios-C/untitled.txt","w");
char* name = "饿了吗？";
fputs(name,pFile);
fclose(pFile);
```

当操作模式是“w”时，如果文件不存在，会创建一个文件（相同路径，名字），如果文件存在，会将原来的文件替换掉

当操作模式是“a”时，如果文件不存在，会创建一个文件（相同路径，名字），如果文件存在，会在原来文件的基础上添加数据

# fgets

- 从指定的流中读取字符串

流：标准输入流---》控制台（scanf )

​       文件流---------〉磁盘上的文件

- 其他函数缺点：

Scanf：不安全，可能存不完；输入空格认为结束

Gets：不安全，可能存不完

fgets优点：安全，存得完；空格也一并接收

- 标准输入流

```c
fgets();
//三个参数，第一个，要将字符串存储到哪一个数组中，第二个，最多接收多少个长度(写的减1个）的字符串，第三个，指定流，stdin 标准输入流
char input[11];
fgets(input,10,stdin);
```

![image-20210729205603491](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210729205603491.png)

```c
char input[5];
fgets(input,5,stdin);
size_t len = strlen(input);
if(input[len - 1] == '\n'){
  input[len - 1] = '\0';
}
```

- 文件流

```c
FILE* pFile = fopen();
fputs();//写入
fclose(pFile);//关闭文件
-------------------------------
FILE* pFile = fopen("/Users/kaixin/Documents/my_github/C-notes/ios-C/untitled.txt","r");
char content[50];//准备一个用来储存字符串的字符数组
fgets(content,50,pFile);
fclose(pFile);
```

# const关键字

- 用来修饰变量，在声明变量的同时

被const修饰的变量有不可变性，成为只读变量

1、修饰基本数据类型的变量

基本数据类型：int,double,float,char

2、修饰数组

数组元素无法更改

3、修饰指针

无法通过指针修改指向变量的值，可以直接修改变量的值,可以修改指针变量的值（使其指向其他变量）

```c
const int num = 10;
//也可以 int const num = 10; 
//num变量只能取值
------------------------------
const int arr[] = {1,2,2332};
//也可以 int const arr[] = {1,2,2332};
-----------------------------
int num = 10;
const int* p1 = &num;
//也可以写 int const* p1 = &num;
//int* const p1 = &num;  p1的值不能修改（p1不能指向其他变量），可以通过p1修改指向变量的值
//int const* const p1 = &nun;  既不能修改p1的值，也不能通过p1修改指向变量的值
```

- 使用情况：

1、被const修饰变量的值，自始自终不会发生变化，也不允许别人修改

2、防止函数把变量数组更改，给参数加const(参数加const的函数放心用)

```c
void printArry(const int arr[],int len){
    for(int i = 0;i < len;i++){
        printf("%d\n",arr[i]);
    }
}
int main(){
    int arr[] = {123,35346,54,64,57,5};
    printArry(arr,sizeof(arr)/sizeof(arr[0]));
return 0;
}
```

# malloc

- 在堆区申请字节空间：

申请的空间如果不主动释放，就不会被系统自动释放，除非程序结束了

- 步骤

1、申请

2、使用

3、释放

- 申请:<stdlib.h>

1、Malloc();

参数，Size_t 类型就是unsigned long

意义：向堆内存中申请连续的几个字节空间

返回值：void*，没有类型的指针。返回的是创建空间第一个字节的地址。声明一个有类型的指针接收malloc的返回值，依据使用者想如何操作申请的空间

![image-20210729214458056](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210729214458056.png)

![image-20210729214710882](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210729214710882.png)

```c
malloc(4);
int* p1 = malloc(4);//当做整形操作，4个字节4个字节操作
*p1 = 100;//把100给4个字节接收
```

```c
#include<stdlib.h>
//给数组用
int main(){
int* p1 = malloc(24);//在堆里面创建1个长度为6的整型数组,malloc返回地址当做指针，
    *p1 = 10;
    *(p1+1) = 20;
    *(p1+2) = 30;
    *(p1+3) = 40;
    *(p1+4) = 50;
    *(p1+5) = 60;
    for(int i = 0;i < 6;i++){
        printf("%d\n",p1[i]);
    }
return 0;
}
```

![image-20210729222216370](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210729222216370.png)

特点：在堆区申请字节的地址是从**低字节到高字节分配**，每次申请到字节地址不一定都挨着。

在堆区申请到字节，里面是有值的，是垃圾值

可能申请失败，如果失败返回的指针是NULL值，**申请完空间后最后判断是否申请成功**

**用完之后释放空间free(指针变量名);**

```c
int* p1 = malloc(120);
if(p1){//申请成功
  for(int i = 0;i < 30;i++){
    p1[i] = i*10;
  }
  for(int i = 0;i < 30;i++){
    printf("p1[%d] = %d\n",i,p1[i]);
  }
  free(p1);
}
```



2、Calloc();

参数，Size_t 类型就是unsigned long

意义：向堆内存中申请连续的几个字节空间

返回值：void*

```c
int* p1 = calloc(3,sizeof(int));
       //连续申请三个int类型空间
if(p1){
  for(int i = 0;i < 3;i++){
    p1[i] = i * 10;
  }
  for(int i = 0;i < 3;i++){
    printf("%d\n",p1[i]);
  }
  free(p1);
}
```

优势：不用计算字节；自动初始化**能用calloc就不用malloc**

3、Realloc();

作用：扩容

指针几乎可以操作内存中每一个字节，但还是只操作自己申请的字节空间。

当之前在堆区申请的字节空间不够用时，用realloc(如果下一个空间被使用，系统会给你在别的地方的空间用，并把之前的数据拷过来，把之前的数据释放)

```c
int *p1 = calloc(10,sizeof(int));
//发现空间不够用，需要继续申请
int*p2 = realloc(p1,4);//扩容4个字节

```

- ```c
  int* arr = calloc(10,sizeof(int));
  int* p1 = calloc(10,sizeof(double));
  for(int i = 0;i < 10;i++){
    arr[i] = (i+1)*10;
  }
  int* arr1 = realloc(arr,115);
  for(int i = 0;i < 10;i++){
    printf("%d\n",arr1[i]);
  }
  ```

# 推箱子

```c
/*
 1、将地图上每一个格子的类型保存起来
 墙：
 路：
 人：
 箱子：
 2、游戏流程
 
 while(1){
 1）打印地图
 2）接收输入小人的前进方向
 3）根据小人的前进方向来移动
 }
 */
#include <stdio.h>
#include <stdlib.h>
#define ROWS 10
#define COLS 11  //'\0'

///地图数组
char map[ROWS][COLS] = {
    "##########",
    "#  ####  #",
    "# X####  #",
    "# O      #",
    "######   #",
    "#  ####  #",
    "#        #",
    "#   ######",
    "#         ",
    "##########"
};
int personCurrentRow = 3;
int personCurrentCol = 2;

void showMap(void);
char enterDirection(void);
void moveToLeft(void);
void moveToUp(void);
void moveToRight(void);
void moveToDown(void);
int main(){
    while(1){
        system("clear");
    // 1、根据地图打印
    showMap();
    // 2、接收小人前进方向
    char dir = enterDirection();
    //3、根据小人的前进方向来移动
    switch(dir){
    case 'a':
    case 'A':
        //向左
            moveToLeft();
        break;
    case 'w':
    case 'W':
        //向上
            moveToUp();
        break;
    case 'd':
    case 'D':
        //向右
            moveToRight();
        break;
    case 's':
    case 'S':
        //向下
            moveToDown();
        break;
        case 'q':
        case 'Q':
            printf("你的智商真低！\n");
            return 0;
        //等价于defult:
        //break;
    }
        if(personCurrentRow == 8){
            if(personCurrentCol == 8){
                printf("你的智商真高！\n");
            }
        }
    }
    return 0;
}
/// 1、根据地图打印
void showMap(void){
    for(int i = 0;i < ROWS;i++){
        printf("%s\n",map[i]);
    }
}

/// 2、接收小人前进方向
char enterDirection(void){
    printf("请输入小人是前进方向 a.左 w.上 d.右 s.下 q.结束\n");
    char dir = 'a';
    rewind(stdin);
    scanf("%c",&dir);
    return dir;
}
void moveToLeft(void){
    //0、小人现在坐标计算小人左面的坐标
    //2、是墙，不动；是路，动；是箱子：判断箱子左面格子类型，是路就推，是墙就不动
    int personNextRow = personCurrentRow;
    int personNextCol = personCurrentCol - 1;
    //1、判断左面的格子类型
    if(map[personNextRow][personNextCol] == ' '){
        //是路，移动，交换值
        map[personNextRow][personNextCol] = 'O';
        map[personCurrentRow][personCurrentCol] = ' ';
        //更改小人位置
        personCurrentRow = personNextRow;
        personCurrentCol = personNextCol;
    }else if(map[personNextRow][personNextCol] == 'X'){
        //是箱子，再判断能不能推
        //1）、找到箱子左面格子的坐标
        int boxNextRow = personNextRow;
        int boxNextCol = personNextCol - 1;
        //2）、判断格子类型
        if(map[boxNextRow][boxNextCol] == ' '){
            //推
            //1）箱子左一个格子是箱子
            map[boxNextRow][boxNextCol] = 'X';
            //2）当前箱子的格子是小人
            map[personNextRow][personNextCol] = 'O';
            //3）小人的位置是空格
            map[personCurrentRow][personCurrentCol] = ' ';
            //推完之后改变小人的位置
            personCurrentRow = personNextRow;
            personCurrentCol = personNextCol;
        }
    }
}
void moveToUp(void){
    //0、小人现在坐标计算小人上面的坐标
    //2、是墙，不动；是路，动；是箱子：判断箱子上面格子类型，是路就推，是墙就不动
    int personNextRow = personCurrentRow - 1;
    int personNextCol = personCurrentCol;
    //1、判断上面的格子类型
    if(map[personNextRow][personNextCol] == ' '){
        //是路，移动，交换值
        map[personNextRow][personNextCol] = 'O';
        map[personCurrentRow][personCurrentCol] = ' ';
        //更改小人位置
        personCurrentRow = personNextRow;
        personCurrentCol = personNextCol;
    }else if(map[personNextRow][personNextCol] == 'X'){
        //是箱子，再判断能不能推
        //1）、找到箱子上面格子的坐标
        int boxNextRow = personNextRow - 1;
        int boxNextCol = personNextCol;
        //2）、判断格子类型
        if(map[boxNextRow][boxNextCol] == ' '){
            //推
            //1）箱子下一个格子是箱子
            map[boxNextRow][boxNextCol] = 'X';
            //2）当前箱子的格子是小人
            map[personNextRow][personNextCol] = 'O';
            //3）小人的位置是空格
            map[personCurrentRow][personCurrentCol] = ' ';
            //推完之后改变小人的位置
            personCurrentRow = personNextRow;
            personCurrentCol = personNextCol;
        }
    }
}
void moveToRight(void){
    //0、小人现在坐标计算小人右面的坐标
    //2、是墙，不动；是路，动；是箱子：判断箱子右面格子类型，是路就推，是墙就不动
    int personNextRow = personCurrentRow;
    int personNextCol = personCurrentCol + 1;
    //1、判断右面的格子类型
    if(map[personNextRow][personNextCol] == ' '){
        //是路，移动，交换值
        map[personNextRow][personNextCol] = 'O';
        map[personCurrentRow][personCurrentCol] = ' ';
        //更改小人位置
        personCurrentRow = personNextRow;
        personCurrentCol = personNextCol;
    }else if(map[personNextRow][personNextCol] == 'X'){
        //是箱子，再判断能不能推
        //1）、找到箱子右面格子的坐标
        int boxNextRow = personNextRow;
        int boxNextCol = personNextCol + 1;
        //2）、判断格子类型
        if(map[boxNextRow][boxNextCol] == ' '){
            //推
            //1）箱子右一个格子是箱子
            map[boxNextRow][boxNextCol] = 'X';
            //2）当前箱子的格子是小人
            map[personNextRow][personNextCol] = 'O';
            //3）小人的位置是空格
            map[personCurrentRow][personCurrentCol] = ' ';
            //推完之后改变小人的位置
            personCurrentRow = personNextRow;
            personCurrentCol = personNextCol;
        }
    }
}
void moveToDown(void){
    //0、小人现在坐标计算小人下面的坐标
    //2、是墙，不动；是路，动；是箱子：判断箱子下面格子类型，是路就推，是墙就不动
    int personNextRow = personCurrentRow + 1;
    int personNextCol = personCurrentCol;
    //1、判断下面的格子类型
    if(map[personNextRow][personNextCol] == ' '){
        //是路，移动，交换值
        map[personNextRow][personNextCol] = 'O';
        map[personCurrentRow][personCurrentCol] = ' ';
        //更改小人位置
        personCurrentRow = personNextRow;
        personCurrentCol = personNextCol;
    }else if(map[personNextRow][personNextCol] == 'X'){
        //是箱子，再判断能不能推
        //1）、找到箱子下面格子的坐标
        int boxNextRow = personNextRow + 1;
        int boxNextCol = personNextCol;
        //2）、判断格子类型
        if(map[boxNextRow][boxNextCol] == ' '){
            //推
            //1）箱子下一个格子是箱子
            map[boxNextRow][boxNextCol] = 'X';
            //2）当前箱子的格子是小人
            map[personNextRow][personNextCol] = 'O';
            //3）小人的位置是空格
            map[personCurrentRow][personCurrentCol] = ' ';
            //推完之后改变小人的位置
            personCurrentRow = personNextRow;
            personCurrentCol = personNextCol;
        }
    }
}
```

# 指针与函数

![image-20210730205138866](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210730205138866.png)

- 指针作为函数的返回值

```c
//错误示范
int* test(){
  int arr[] = {10,20,30};
  return arr;//arr是地址，返回指针
}
int main(){
  int* arr = test();//（局部变量）arr数组的数据离开函数就被释放，访问的不一定就是数组元素 
  for(int i = 0;i < 3;i++){
    printf("%d\n",arr[i]);
  }
  return 0;
}
-----------------------------------------------
  //放到堆区里
  int* test(){
  int* arr = calloc(3,sizeof(int));
*arr = 10;
*(arr+1) = 20;
*(arr+2) = 30;
return arr;
}
int main(){
  int* arr = test();
  for(int i = 0;i < 3;i++){
    printf("%d\n",arr[i]);
  }
  free(arr);
  return 0;
}
```

 ![image-20210730210606706](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210730210606706.png)

**返回值可以是局部变量的值，不能 返回局部变量的地址**

如果要返回局部变量的地址，得在堆里分配空间

- 返回字符串：

返回值类型 chr*

直接返回（储存在常量区，离开函数不会被回收）

```c
//写一个函数，传入星期数，返回对应星期名
char* getWeekDay(int day){
    switch(day){
        case 1:
            return "mon";//字符串本质是地址，返回类型是指针
            ……
        default:
            break;
    }
}
------------------------------------
  char* getWeekDay(int day){
  char *weekDay = NULL;
    switch(day){
        case 1:
            weekDay = "mon";//字符串本质是地址，返回类型是指针
            ……
        default:
            break;
    }
  return weekDay;
}
```



- C语言中字符串常量的本质表示其实是一个地址，C语言中编译器会给字符串常量分配地址，字符串常量的本质表现是代表它的第一个字符的地址

给字符串分配地址

char *s;

s= "hello";

s就是当前字符串的首地址

- ![image-20210730213632873](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210730213632873.png)

# 指向函数的指针

- 指针指向内存中一个字节空间

程序在运行时，会把代码/指令加载到内存

函数存储在内存的代码段中，有一块空间，有空间就有地址，有地址就可以有指针

函数调用：函数名，指向函数的指针

- 有的函数才可以有指针：指向函数的返回值类型和参数描述 必须与指针的描述一样

```c
返回值类型（*指针名)([参数列表]);
-------------------------------
void(*pFunction)();
//指向函数的指针，名字是pFUnction
//只能指向没有返回值，没有参数的函数
-------------------------------
  int(*pFunction)(int num1,int num2);
//只能指向返回值int，并有两个整形参数的函数
```

- ![image-20210730215831301](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210730215831301.png)

- 初始化

取到函数地址，赋值给指针变量

**函数的名称就是函数的地址**

```c
void test(){
  printf("abababa");
}
void(*pFunction)() = test;
//pFunction指针指向test函数
```

![image-20210730215204499](4%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8C%87%E9%92%88.assets/image-20210730215204499.png)

- 通过指针调用函数

```c
pFunction();
//or
(*pFunction)();
//(*pFunction)等价于test函数，(*pFunction)()等价于test()
```

- 接收返回值

有参数就给，有返回值就接

```c
int getSum(int num1,int num2){
int sum = num1 + num2;
  return sum;
}
int main(){
  int (*pFunc)(int num1,int num2) = getSum;
  int sum = pFunc(10,20);
  //接收返回值，按照函数名使用方法正常搞就行
  printf("%d",sum);
  return 0;
}
```

