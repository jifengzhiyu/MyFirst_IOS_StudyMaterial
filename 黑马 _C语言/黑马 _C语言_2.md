# 类型

- 内存条里面存储数据：每个数据需要一个位置，每个位置都有地址

通过地址找数据

挖坑：（开辟空间）

自己制定坑的别名（对变量命名）

制定坑的类型（变量类型）：坑里可以放数据的类型

类型：

![image-20210719223340879](%E5%8F%98%E9%87%8F-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.assets/image-20210719223340879.png)

![image-20210719223753148](%E5%8F%98%E9%87%8F-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.assets/image-20210719223753148.png)

```c
printf("%d\n",INT32_MAX);
//看
```

各个类型的变量长度是由编译器来决定的，而当前主流的编译器中一般是32位机器和64位机器中int型都是4个字节。

# 变量

- 变量：内存中开辟的来存储数据的空间（坑，空间，变量）

变量的值：数据

- 在内存中开辟空间，存储数据：声明变量

- 如果给int浮点类型数据，只会保留整数部分，不会 四舍五入

- 写小数，默认double类型

- char（1个字节）字符类型，只能存1个字符，可以存空格，不能存中文（一个中文3个字节）（多出来的只存最后一个）

- printf显示变量的值，需要一个占位符占位，%d

Float 打印：%f（默认输出小数点固定的6位数，不够的用000）

在默认情况下以%f格式输出的情况下会输出6位小数位，但并不能保证这6位小数有效，即：是否有效还要看整数位和小数位加在一起是否超过7位。

![image-20210720112717834](%E5%8F%98%E9%87%8F-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.assets/image-20210720112717834.png)

char打印：%c

double也可以%lf打印(按道理来说double输入输出都用%lf)

- 变量只声明一次
- 变量的命名：

![image-20210720161041878](%E5%8F%98%E9%87%8F-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.assets/image-20210720161041878.png)

```c
float a = 12.21f;
//比较正确
float a = 12.21；
//也可以，自动类型转换
```

# 赋值

```c
int num1 = 1,num2 = 2;
```

- 声明变量，没有赋值，变量的值是垃圾值（随机数）

- 变量可以重复赋值（新值会将旧值干掉）

- 可以将一个变量的值给另一个变量赋值

# 打印

- 对于整数

![image-20210720162311955](%E5%8F%98%E9%87%8F-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.assets/image-20210720162311955.png)

- %0md,不足位数的用0补齐（在数的前面）

%md，的m是最少输出的位数（所以会出现补齐现象）

- 对于浮点数（实型数据）：

```c
double a=1.2345;
  printf("%4lf",a);
//1.234500,看来浮点类型不走这一套,还是共输出7位有效数字
```

固定输出 小数点后面多少位(n位）：%.nf or %.nlf

（但是这种规定输出小数点后确定位数的输出会 做四舍五入。）

# 类型转换

- 自动类型转换

变量类型int，赋值超过范围，产生垃圾值；赋值小数，自动类型转换整数类型

变量类型浮点数类型，赋值整数，加.0

- ASC II码（整数）：每个字符都有对应的整数

‘A' 65

’a' 97

‘0’ 48

给char类型赋值可以直接赋值ASKII 码

# scanf

```c
int num;
scanf("%d",&num);//&是取地址，%d占位符
```

scanf阻塞式函数，指向到这个函数CPU会暂停（等待输入）

scanf“”里面 只 有**占位符**

```c
scanf("%d%d",&a1,&a2);//写入多个变量的值
//写一个数据用 空格或回车 再输入下一个(最好回车）
//因为scanf会先看缓冲区有没有数据，有的话就直接用了。
 printf("分隔符1\n");
    int a = 0;
    scanf("%d",&a);
    printf("%d\n",a);
    
    int b = 0;
    printf("分隔符2\n");
    scanf("%d",&b);
    printf("%d\n",b);
    //输入 12 空格 2，就会直接出来两个printf
//输入12 回车 2,就会得到理想效果(针对整数和浮点数）
-----------------------------
//scanf需要输入什么就输入什么
scanf("%d-%d",&a1,&a2);
//输入：数字-数字
```

- scanf一个语句里面输入： 整数浮点数 与 字符类型时，必须分开写两句话（中间插入清空语句）,原因如下：（不然字符会出现回车，空格等等）

![image-20210720214938871](%E5%8F%98%E9%87%8F-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.assets/image-20210720214938871.png)

不会忽略任何数据的时候包括空格，回车等等

```c
rewind(stdin);
//将缓冲区的数据清空
```

# 交换变量的值

```c
//还真的是转圈，num1,num2变量交换
int temp = num1;
num1 = num2;
num2 = temp;
-------------
//不用第三方变量，相加再相减
  num1 = num1 + num2;
  num2 = num1 - num2;
  num1 = num1 - num2;
```

# 算数运算符

- % 求模运算符，只有整数运算

![image-20210721115318897](%E5%8F%98%E9%87%8F-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.assets/image-20210721115318897.png)

m % n=[0,n-1]

- 算数表达式，由算数运算符链接起来的式子

- 操作数，参与运算的数字/变量

若操作数类型不一样，结果的类型就是类型范围最大 的操作数 的类型

除法：如果想让结果有小数部分，将任意一个操作数改成浮点类型

或

将第一个操作数*1.0（类型转换成double）

 # 算数运算符优先级

![image-20210721120626620](%E5%8F%98%E9%87%8F-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.assets/image-20210721120626620.png)

- char类型可以参与算数运算：结果int

实质是ASC II码的计算，整数的计算

```c
//A:65,a:97
char ch1 = 'A';
char ch2 = 'a';
int sum = ch1 + ch2;
char count = ch2 - 32;
printf("%d\n%c\n",sum,count);
```

ASCII排序：大写在前，大写到小写+32，小写到大写-32

# 复合赋值运算符

- +=，-=，/=，%=

```c
num += 2;
//num = num +2;
```

做计算并赋值

# 自增自减

- 自增运算符 ++
-  自增表达式（自身的值加一）

前自增表达式：++num（运算符在变量之前）:先将num的值加一，再将自身的值（加过一了的）作为表达式的结果

```c
int i=1;
int j=++i;
//i=j=2
```



后自增表达式：num++（运算符在变量之后）:先将num到值作为后增表达式的结果，再将自身的值加一

```c
int i=1;
int j=i++;
//j=1,i=2
```

- 先自增再算数

- 一般就用**i++**

# 逗号表达式

- 逗号是运算符

- 逗号表达式：由逗号链接起来的一个式子（由多个子表达式构成）

**最后一**个子表达式是整个逗号表达式的结果

逗号表达式的目的，执行前面的子表达式，要最后一个表达式的结果

- 赋值运算符高于逗号运算符

# 比较表达式

- 比较运算符/关系运算符：变量，常量，表达式，字符（比较ASKII码）
- 比较表达式：由比较运算符链接的式子

Int 0,1假，真

- 常量，直接写的数据：

- 顺序：
- ![image-20210721181546695](%E5%8F%98%E9%87%8F-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.assets/image-20210721181546695.png)

# 逻辑表达式

- 逻辑运算符，多个条件之间的关系

&& 逻辑与，并且（如果任何一个条件不满足，就结束该语句）

|| 逻辑或 （如果任何一个条件满足，就结束该语句）

! 取反：优先级 高于 比较运算级 

- 逻辑表达式：逻辑运算符链接起来的条件

- 逻辑运算符优先级：not and or

![image-20210721204758831](%E5%8F%98%E9%87%8F-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.assets/image-20210721204758831.png)

- 条件表达式：比较表达式+逻辑表达式

# 运算符的优先级和结合性

- 单目运算符/一元运算符：参与运算的操作数1个

双目运算符/双元运算符：参与运算的操作数2个

三目运算符/三元运算符：参与运算的操作数3个

- C语言有15个运算优先级，1最高，15最低

![image-20210721212225152](%E5%8F%98%E9%87%8F-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.assets/image-20210721212225152.png)

# IF（判断结构）

```c
if(条件表达式）{
  执行代码;
}
   //（）里面是0才是假，非零就是1，代表真
```

- 分号：语句的最后，代表 指令的结束

- 凡事带大括号的，就当做一个**语法块**

右大括号代表语法块的结束

- 如果if块中只有一句代码，大括号可以省略

如果大括号省略，只有之后的第一句代码是if块里的

- 如果if块中只有一句语法块，大括号可以省略

```c
int num = 1;
if(num > 0)
  for(int i = 0;i < 10;i+){
    printf("$d\n",i);
  }
```

 

# 变量的作用域

- 回收内存：

声明在大括弧内部的变量，在大括弧结束的时候立即被回收

可以手动加大括弧来规定变量的作用域，提前回收内存

- 变量的作用域：变量可以访问的范围

离变量最近大括弧的范围

- 在不同层级的作用域可以定义名称相同的变量

内层作用域同名的变量会将外层作用域同名的变量屏蔽

内层作用域访问定义在内层的变量

外层作用域访问定义在外层的变量

# IF-ELSE（IF）

```c
if(条件表达式）{
  执行代码；
}
   else{
     执行代码；
   }
```

- If-else if-else,,,,,,,需要按顺序判断多个条件（条件范围由大到小），只要一个成立，就执行对应的事情，后面的就不需要判断了。只有前面的条件不成立，才判断后面的条件

```c
if（条件表达式1）{
  执行代码;
}else if(条件表达式2){
  执行代码；
}else if(条件表达式3）{
  执行代码;
}else{//可以连续多个，只要最后是else就行
  执行代码；
}
```

- 如果条件的顺序乱序（不是范围由大到小），那么条件就要上限下限写完整

- else if可以任意个

# 三元表达式=IF-ELSE

- 条件表达式 ？ 值1: 值2；

如果条件表达式成立，三元表达式就是值1，否则结果就是值2

值1，2可以是打印等等

```c
int a=1>0 ? printf("adad"): printf("1111");
```

- 值1，2只限定一个语句
- printf的返回值是打印的内容占据多少字节

# 随机数

```c
//引入系统头文件,系统标准库(std-- standard）（lib--library)
#include<stdlib.h>
int num = arc4random_uniform(10);
//在arc4random_uniform函数里面传入一个整数，就会返回【0,n-1】的随机数，并赋值给num
```

```c
//10-20随机数
#include<stdlib.h>
int num = arc4random_uniform(11)+10;
```

```c
//产生指定范围的随机数：
int num = arc4random_uniform(最大数-最小数+1)+最小数;
```

# switch-case选择结构

- switch开关，case情况 

```c
switch(任意，除了浮点数）{
  case 值1:
      执行代码;（任意行）
      break;
  case 值2:
      执行代码;
      break;
  case 值3:
      执行代码;
      break;
  default://可以省略default语句
      执行代码;
      break;
}
```

执行步骤：

1、计算switch后面表达式的结果

2、将1点结果和case后面的**值**（非变量）进行比较判断，如果**相等**就结束其中的代码，结束

3、如果所有case后面的值和表达式的结果都不相等，执行default中的代码

- case穿透

break，立即结束整个switch结构

如果没有break，一旦满足条件就执行该case的代码，并会穿透到下一个case中执行代码，直到遇到break或执行完毕

- switch后面 不 加小数：因为小数在内存里不是准确的

- 如果case块内要声明变量，该case块必须加大括弧

- 使用switch-case可以使用if写，但if不全可以用switch- case写

Switch-case只能做等值判断，不能做范围判断

- 等值判断一般用switch- case，范围判断一般用if

# 循环简介

- 循环：同一段代码 反复不停地执行指定的次数

- 循环结构：

while，约等于do-while，while等于For（最常用）

- 循环的选择：循环次数确定：for

循环次数不确定（死循环）while

- 循环的选择：循环次数确定：for

循环次数不确定（如死循环）while

# while

```c
while(任意表达式,循环继续的条件）{//循环头
  那段需要被反复不停执行的代码；//循环体（任意行）
}//循环继续的条件用到的变量需要声明在循环体外面
```

- 死循环

- 永真永假：while（1）；while（0）；

```c
//指定循环次数：n次
int i=0;//循环增量的声明
while(i<n)
{
  循环体；
  i++;
}
```

- 书写

1、确定循环体：写架子

（2、确定循环次数），可能不知道

3、确定循环条件:循环条件的变量声明在循环体外面

- 应用：

累加和，平均值

求最大最小值

找出指定范围中符合特定条件的数（遍历）

确定循环次数的循环

循环次数不确定，条件确定

遍历指定范围的数

计数

穷举（挨个试）

- int类型最大值，最小值： INT32_MAX,  INT32_MIN

# break 和 continue

- break：

switch- case中

循环体的内部，直接结束**当前循环**

```c
//不会执行i++
for(int i = 0;i < 10; i++){
  printf("%d\n",i);
  if(i == 5){
    break;
  }
}
```



- continue：在循环体中，立即结束**本次循环体**，然后回去判断循环条件

在for循环中，还会执行**循环后**操作表达式

# do-while

```c
do{
  循环体；
}while(条件表达式）;
```

- 循环次数与while一样，只不过一定先执行一次

- 等价于

```c
while(1)
{
  break;
}
```

# for

```c
for(初始化表达式；循环条件表达式；循环后操作表达式）{
  循环体；
}
    /*1、执行初始化表达式
      2、判断循环条件表达式的真假
      2.1真，执行循环体，循环后操作表达式，到第二步骤
      2.2假，结束for循环
      如果第二个表达式省略，就默认循环条件是成立的
      只能是三条语句，三个；
```

- 与while一样

循环增量的声明：初始化表达式

循环条件：循环条件表达式

修改循环增量的值：循环后操作表达式

```c
for(;;){

}//死循环
```

- 如果for块中只有一句代码，大括号可以省略

如果大括号省略，只有之后的第一句代码是for块里的

- 如果if块中只有一句语法块，大括号可以省略

```c
int num = 1;
if(num > 0)
  for(int i = 0;i < 10;i+)
    printf("$d\n",i);
```

 

# 嵌套循环

- 循环的循环体里面又包括循环结构

- 外层循环 循环一次，内层循环循环所有次

- \t一个制表符：Tab

- 9*9乘法表

![image-20210723200328926](%E5%8F%98%E9%87%8F-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.assets/image-20210723200328926.png)

```c
/*一共9行
写一个循环，循环9次，每次打印一行
每一行表达式的个数与行数一致*/
for(int i=1; i<=9; i++){
  for(int j=1; j<=i; j++){
    printf("%d*%d=%d\t",j,i,j*i);
  }
  printf("\n");
}
```

# 代码结构

1、顺序结构

每一句代码都执行

2、分支结构

if（判断结构），switch- case（选择结构），让代码出现多个分支，选择一个分支执行

3、循环结构

# goto

- goto去哪儿：将CPU的执行跳转到当前函数别的地方继续执行

- 使用：

1、先给想要跳转到的地方做一个标记，为这个地方取一个标签名（取标签名下面的那一句代码**不**能是声明变量）。

如果非要让取标签名下面的那一句代码是声明变量的话，就在下面写一段没有意义的代码

```c
//没有意义的代码，如
printf("");
```



2、想要在什么地方跳转到做标记的地方（可以往前跳，往后跳转，**只能在当前函数跳转**），就在那里写上goto 标签名；

标签名随意，要符合标识符的规范（标识符：程序员可以自己命名的东西。变量名，标签名，函数名）

```c
loop:
printf("111\n");
printf("222\n");
printf("333\n");
goto loop;//printf("333\n");执行完了之后回到printf("111\n");开始再继续执行
```

3、执行原理：执行到goto时，CPU会跳转到指定标签的地方继续往下执行

- 有时也可以代替循环

```c
int userName = 0,password = 0;
loop:
printf("用户名:");
scanf("%d",&userName);
printf("密码:");
scanf("%d",&password);
if(userName !=123456 || password !=88888888){
  goto loop;
}
```

```c
//往后跳转
printf("111\n");
goto loop;
printf("222\n");
loop:
printf("333\n");
```



- 容易成为死循环
