#  函数的基本使用（不含参数）

- 使用函数大意

1）把代码封装进函数里

2）用的时候调用这个函数就行

- 使用代码情况：

1、重用代码

2、一段代码有一段相对独立的功能，未来以后方便利用，简洁，也把这段代码封装到函数里

- 使用函数好处：

1、简洁

2、修改方便

3、屏蔽代码的实现（黑箱，更抽象思维）

- 函数的定义，在main函数外面

- 语法：

```c
返回值类型 函数名 （参数列表）{//函数头
   函数体；
}//参数可以不写
```

- 函数的调用：

只会执行main函数内部的代码

1、在需要执行的地方调用这个函数

调用函数的语法：

```c
函数名（）；
```

2、CUP执行到调用函数语句时，会跳转到函数内部执行代码，执行完了回到main函数里面继续执行

# 全局变量

- 局部变量：定义在函数里面（在函数内访问）
- 全局变量：定义在函数外面的变量(从定义全局变量的地方开始，后面所有函数都可以访问该全局变量)

- 局部变量没有初始化是垃圾值，全局变量没有初始化默认0（char类型默认\0，不可见的字符，ASK II就是0）

- 创建回收时间：

局部变量：声明局部变量语句的时候创建，作用域结束回收

全局变量：程序启动创建，程序结束回收

- 全局变量特点

共享性（所有函数都可以访问）

可以定义一个和全局变量名称相同的局部变量，在函数内部访问局部变量（不建议命名一样）

# 含参函数

- 函数的参数：在小括弧中声明参数的时候，就是声明一个变量，参数的本质就是定义在函数内部的一个局部变量

依然这样，就不需要在函数体里面定义函数的参数了

```c
函数类型 函数名（类型+参数）{//可以声明多个参数，用逗号隔开void test(int num1,int num2,int num3){},调用的时候必须给函数的每一个参数赋值
  函数体；
}//定义函数，如果不给参数的类型，类型默认int
 函数名 （参数的值）；//函数的调用
   //若有多个参数，按顺序赋值，test(10,20,30);
```

- 形参：形式参数，声明在函数名后面小括弧里的参数

实参：实际参数，调用函数给形参赋的**值**

- 值传递：调用者将实参变量传递给函数，不管函数内部如何操作形参，对实参变量没有任何影响

```c
void test(int num){
  num++;
  num++;
}
int main(){
  int num = 10;
  test(num);
  printf("%d",num);
  return 0;
}//打印10，这两个num变量不是同一个变量
```



- 函数的调用执行步骤：

1、加载被调用的参数

2、声明函数的参数

3、将实参**赋值**给形参

4、执行函数体

5、返回main函数继续往下

- 函数内部对参数的值不确定，只有调用者在调用函数的时候才会把值**传递**进参数

- 函数的参数可以写完之后最后加进去

# return

- return；在函数体中遇到，立即结束这个函数的执行

```c
void panDuanOuShu(int num){
  if(num % 2 ==0){
    printf("是一个偶数\n");
    return;
  }printf("不是一个偶数\n");
          }
```

- 作用，提前结束函数

# 带返回值的函数

- 把函数的结果给调用者使用

- 使用：

1、确定返回给调用者数据类型

2、修改函数的返回值为 要返回的数据类型

3、函数体最后，使用return将数据返回，return sum;

4、拿到返回值，需声明一个和函数返回值类型相同的变量来接收（通过赋值符号） int num = getSum(10,20);

- return 可以返回表达式，实际返回表达式的值

```c
//判断偶数
int panDuan(int num){
  return !(num%2);
}
//！0 = 1
//！非0 = 0
```

- 不带返回值的函数：函数类型void，可以不加函数体结尾的return；

带返回值的函数，函数体内一定要return（函数体内的每一个分支结束前都要有返回值），但是可以在调用之后不接收函数返回的值

- 函数只能返回一个值

# 函数的声明和定义

- 创建函数的完整步骤

1、函数的声明：函数头加分号

函数的声明放在顶部，头文件的下面

```c
void test();
```

告诉编译器函数是有的，只是不知道位置

2、函数的定义（实现）：函数头，函数体

- 如果被调用的函数在主调函数之前（函数里面调用其他函数），被调用函数的声明可以省略

否则就要在使用前调用

```c
void test1(){
}
void test2(){
  test1();
}
-----------
 void test1();
  void test2(){
  test1();
} 
void test1(){
}
```

- 在声明函数的时候可以把参数的名字省略，只保留类型（但还建议都写上）

- 如果返回值是int类型可以不写函数的声明

- main函数放在最前面，函数的声明写在头文件下面，声明和函数头一致

# 预处理指令/预处理代码概述

- c语言代码的分类：

1、C代码

2、预处理代码：命名----写.c源文件----编译（执行.c文件的**预处理代码**----检查语法---编译成.o目标文件）---链接--执行，

以#开头的代码，没有分号

- 预处理指令的分类：

1、文件包含指令 #include

2、宏定义 #define

3、条件编译指令 #if

# 文件包含指令#include

- 作用：将指定文件的内容**拷贝**到写指令的地方
- 语法：

```c
#include "文件路径"//先去当前源文件所在的目录查找该文件，如果没有去编译器目录找，没有，就报错
#include <文件路径>//只去编译器目录找，没有，就报错
```

- 系统自带的编译器目录![image-20210724225827411](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210724225827411.png)
- 1、把被包含的文件放在和当前.c文件一样的目录里面

2、如果包含的文件是自定义的文件用双引号，如果用系统自带的文件用尖括号

- 写路径的时候写一个**相对路径**，把与当前源文件路径相同的部分删除（使其在别的电脑上也能使用）
- 绝对路径：路径从根目录开始

相对路径：相对于当前文件夹的路径，删除和当前文件夹相同的路径



# 系统编译器目录

- C语言标准函数库：类似printf,scanf……

一个名字，带一个小括弧，；   

- .h：头文件：苹果把所有类似功能的函数的 声明 放在1个头文件里，把所有的头文件放在系统的编译器目录里
- stdio.h存储与输入输出相关函数的声明

#include<stdio.h> 把编译器目录里的stdio.h这个包含函数声明的头文件拷贝进源文件

# 多文件夹开发

- 程序由一个个模块组成，一个模块就是一个功能，功能由函数实现，要使用功能，直接调用就行

程序函数过多时，需要分模块开发，

- 可以在一个文件夹里面建2个.c文件，1定义函数，2使用函数，2使用之前写函数的声明就可以用

- 写一个模块需要两个文件：

.c 函数的实现（定义）

.h函数的声明

调用函数的时候只要包含这个模块的头文件#include "sum.h"

# 四种进制

- 一种计数的方式，看逢多少进一,**都是整数**

- C语言可以识别的进制：

1、二进制：在二进制数的前面加一个 

**0b** 的前缀

```c
int num = 0b010010110101
```

二进制输出不了

2、八进制:0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20

在八进制数的前面加 **0**

```c
int num = 0134;
```

**%o**将整形变量的数用八进制放方式输出

3、十进制：%d将整形变量的数用十进制放方式输出

C语言直接写一个整数，默认十进制

4、十六进制：1 2 3 4 5 6 7 8 9 a b c d e f 10

123acf下一个数123ad0

在十六进制数的前面加一个 **0x**的前缀

```c
int num = 0x12acd;
```

**%x**将整形变量的数用十六进制放方式输出

# 有关进制的概念

- 数码：该数据的每一位上的数字
- 数位：数码在这个数中的位置，从右到左，依次递增，从0开始

- 基数：每一个数码可以有多少个数据来表示（二进制基数2，十进制基数10）
- 位权：数码 乘以 基数的数位次方

0b1001**1**001

数码：1

数位：3

基数：2

位权：1*（2^3）=8

# 进制的转换

![image-20210725161645248](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210725161645248.png)

- 十进制转换二进制：

除二取余法：

把这个数2，，直到余数是1或者0，再将余数倒序，就是十进制对应的二进制

![image-20210725124117276](../../basic_cs_learning/image-20210725124117276.png)

10的二进制1010

- 二进制转换十进制：

加权法：将二进制数的每一个数码的位权相加

- 十进制转换八进制：

除8取余，直到余数小于8为止

- 八进制转换十进制：

加权法：将八进制每一个数码的位权相加

- 二进制转换八进制：

三合一：

将二进制由地位到高位每三位分成一组，高位不够补0。将每一组转化为十进制。将每一组十进制连起来

001 011 100 110 011

1       3       4     6    3

13463

- 八进制转换二进制：

一拆三：将八进制数的每个数码拆成一个三位的二进制数，把二进制数连起来

134674

001 011 100 110 111 100

001011100110111100

- 二进制转换十六进制：

四合一：将二进制由地位到高位每四位分成一组，高位不够补0。将每一组转化为十六进制。将每一组十六进制连起来

- 十六进制转换二进制：

一拆四法则：将十六进制数的每个数码拆成一个四位的二进制数，把二进制数连起来

- 八进制转换十六进制：

八进制---》二进制---》十六进制

# 内存与变量

- 内存中的数据存储单元是由一个个1个的二进制位组成

把八个二进制位分成一组：1个字节，字节是存储数据的最小基本单位

一个字节最多256个数据（2^8）

- 8个二进制位（bit）=1个字节（byte）

1024个字节 = 1KB（1千字节）

1024KB = 1MB（兆）

1024MB = 1GB

1024GB = 1TB

- 声明变量的时候申请一块空间，一块指定字节数的连续字节空间

int 4字节

double 8字节

Float 4字节

Char 1字节

- 变量在内存中占据的字节数会因为系统版本和编译器的不同而改变

# sizeof运算符

- 计算变量，常量在**当前系统**内存中占用的字节数
- 语法

```c
sizeof(数据类型);
//返回这个数据类型的变量在内存中占据多少字节
----------------
  int len = sizeof(double);
printf("len = %d\n",len);
//double 占几个字节
-------------------
  sizeof(变量名)；
  //返回这个变量在内存中占据多少个字节
-------------------
  int num = 100;
 int len = sizeof(num);
printf("len = %d\n",len);
--------------------
  sizeof(常量)；
  //直接写一个数，就是常量
  //返回这个常量在内存中占据的字节数
  -------------------
 int len = sizeof(1000);
printf("len = %d\n",len);
//默认int类型
```

![image-20210725170715738](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210725170715738.png)

- char类型的变量在内存中占据1个字节

常量占据4个字节

![image-20210725173242405](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210725173242405.png)

# 原码，反码，补码

- 原码，反码，补码都是二进制，只不过是二进制的不同表达形式

数据都是以**补码**的二进制存储的，因为计算机只有加法没有减法，为了低成本计算3+（-2）

![image-20210725180434237](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210725180434237.png)

- 为了表示正负性，让最高位表示数的正负性

最高位0:数是正数

最高位1：数是负数

- 一个int类型的数

最小值：-2147483648

最大值：2147483647

- 原码：最高位表示符号位，剩下的位数是这个数绝对值的二进制

- 反码：正数的反码就是其原码

负数的反码：在其原码的基础上，符号不变，其他位取反

- 补码：

正数的补码就是其原码

负数的补码在其**反码**的基础上加一 

![image-20210725175605362](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210725175605362.png)

# 位运算

- 位运算：一个数的二进制数据的每一位参与运算

- 参与位运算的二进制数据必须是补码形式，位运算的结果也是补码形式

# 按位与 &

- 按位与 &：按位与的两个二进制数，如果都是一，结果就是1，只要有一位是0，结果就是0

![image-20210725181227085](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210725181227085.png)

- 任何数按位与1的结果是：这个数的最低位
- 偶数的最低位一定是0，奇数的最低位一定是1

判断一个数是奇数还是偶数，把这个数按位与1，如果结果是1，就是奇数，是0，就是偶数

- ==的优先级比&高

# 按位或 |

- 参与按位或的二进制数据，如果有一位是1，结果就是1，两位都是0，结果是0

![image-20210725182245393](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210725182245393.png)

# 按位取反 ～

- 单目运算符
- 将二进制的**每一位**取反

# 按位异或 ^

- 参与按位异或二进制数的位，如果相同就是0，不同是1

- 交换两个变量的值

# 按位左移<<

- 向左移动指定的位数，低位不够补0，高位溢出丢弃

3左移2位：

![image-20210725183438227](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210725183438227.png)

- 左移运算可能改变正负性
- 将一个数左移n位，就是将这个数乘以2的n次方

3<<2   3*2^2

5 * 16 = =5 << 4

# 按位右移 >>

- 向右移动指定位数，低位溢出丢弃，高位补符号位

![image-20210725184017507](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210725184017507.png)

- 右移运算不会改变正负性
- 将一个数按位右移n位，就是这个数除以2的n次方

100 >> 2 == 100 / 4

# 深入变量

- 变量占用的字节空间是连续的

内存中储存数据的最小基本单位是字节

每个字节都有一个独一无二的内存地址，是1个十六进制的数（最短表示最多的数）

相邻字节的地址是连续的

- 声明一个变量就是在内存中分配连续的指定字节数的空间

int 4个连续的字节

- 在为变量分配字节空间的时候，是从**高地址向低地址**分配 连续的指定字节数的空间 

![image-20210725185739648](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210725185739648.png)

- 变量中以二进制补码存储

存储的时候低位存储在低字节，高位储存在高字节

- 变量的地址：组成变量 （最）低字节的地址

& 取地址运算符，取出变量的地址

```c
&变量名；//取出变量的地址
%p 打印地址  
  -----------
  int num1 = 10;
int num2 = 20;
printf("num1的地址是%p\n",&num1);
printf("num12的地址是%p\n",&num2);
```

![image-20210725204618324](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210725204618324.png)

# int类型的修饰符

- 来指定int类型的变量在内存中占用的字节数

- short修饰符：

```c
short int num = 10;//等价于short num = 10;
//只占据2个字节，16位
//最小值-32768（2^15)，最大值32767
printf("&hd",num);
```

- long修饰符

```c
long int num = 10;//等价于long num = 10;
//32位操作系统，占据4个字节；64位操作系统，占据8个字节
//8个字节，64位
printf("%ld",num);
```

- Long long 修饰符

```c
long long int num = 10;//等价于long long num = 10;
//占据8个字节
printf("%lld",num);

```

- unsigned修饰符

int ,short ,long ,long long都是最高位表示符号位，所以实际表示数据少了一位

声明int变量(short ,long ,long long）包括的时候加unsigned表示最高位不表示符号，表示数据，这样表示的数据就会增长一倍，最小值就是0

```c
unsigned int num = 9999;
printf("%u",num);
------------------------
 unsigned short num = 10;
printf("%hu",num);
------------------------
  unsigned long num = 10;
printf("%lu",num);
------------------------
  unsigned long long num = 10;
printf("%llu",num);
```

- signed修饰符

最高位作为符号位（默认就是这样），写不写都一样

```c
signed int num = 10;
```

# char变量深入

- 字符数据在内存中存的是字符的ASKII的补码

```c
char ch = 97;
printf("%d",ch);
//可以这么搞，因为char变量本来储存的就是一个整数
```

- char变量是有符号的，最高位表示符号位

![image-20210725213433731](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210725213433731.png)

# 占位符（格式控制符）

- 格式控制符的作用：不同类型的数据在变量中存储的形式不一样。所以读写的方式也不一样，格式控制符来决定以什么类型的读写方式来读写该数据

- 

1、int整形：

**%d    读取，以十进制输出**

%o    读取，以八进制输出

%x    读取，以十六进制输出



%hd   short

%ld    long

%lld   long long



%u    unsigned int

%hu   unsigned short

**%lu     unsigned long**

%llu    unsigned long long

2、实型

float  %f

double  %lf

3、字符型

Char   %c

4、地址： %p

# 垃圾值

- 变量的回收：告诉系统变量占用的字节不用了，可以分给别人（但变量占用字节的数据不会清空）

再声明一个变量的时候，新变量中的值（未初始化）就可能是之前回收变量遗留下来的值，就是垃圾值-

所以要求初始化

- 全局变量：声明了之后，系统会自动把数据清零

# 数组概述

- 数组array：数据的组合

- 特点

1、可以存储多个相同意义的数据

2、只能存储类型相同的多个数据，类型在创建数组的时候就确定了

3、在创建时就确定了数组可以存储数据的个数

4、方便一次管理多个数组

- 声明一个数组

1、确定多个数据的类型

2、确定数组**最多**可以存储数据的个数

```c
int arr[3];
```

- 数组也是一个变量，上面数组的类型是int数组类型

- 内存中的数组：

int arr[3];

1、在内存中声明一个数组变量arr

2、将这个数组平均划分3个**小空间（数组的元素）**

3、每一个小空间的类型是int类型

4、数组里面的小空间存储数据

- 术语：

**元素：本质上是一个个普通变量**

下标/索引：从0开始，给每个元素编的号码

长度：数组中元素的个数（**最多**可以存储多少个数据）

- 存储

数组名代表整个数组，赋值是给数组的元素（用下标）

```c
数组名【元素的下标】 = 数据；
  arr[1] = 100;
 //把100赋值给下标是1的元素
```

- 下标越界赋值，可以赋值的话也不是给数组的元素赋值（可能是别的程序，系统程序等等）

- 取数据：取数组中元素的数据

```c
printf("%d",arr[1]);
```

# 遍历数组

```c
for(int i = 0; i<数组的长度; i++){
arr[i]
}
```

# 数组注意

- 声明数组时必须声明数组的长度：常量，变量，表达式，字符（ASKII），不能是小数，不能是负数，可以是1或0，可以是宏

- 宏：

  ```c
  #define LEN 10//10是宏值
  int arr[LEN];
  ```

- 没有给数组初始化，值是垃圾值

初始化：

```c
1、声明数组，用下标逐个赋值
  int arr[3];
arr[0] = 10;
arr[2] = 20;
arr[3] = 30;
2、在声明数组的同时初始化数组的元素
  int arr[3] = {10,20,30};
//此时数组的长度不能用变量，但是可以用宏（预编译）因为在编译的时候自动把法2转换成法1
3、省略长度
  int  arr[] = {10,20,30}
//数组的长度由大括弧内数据的个数决定
4.只给数组的部分元素赋值，剩下的元素自动初始化为0
  int  arr[3] = {10}
//如果要将数组所有元素初始化为0,int arr[3] = {0}
5、指定下标的初始化
  int arr[3] = {[1] = 10,[2] = 20};
//剩下的元素默认值0
```

# 数组与内存，地址

![image-20210726113429408](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210726113429408.png)

![image-20210726113523833](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210726113523833.png)

- 数组的地址是：数组中 最低字节的地址

即 是数组中下标为0元素的低字节地址

- 数组名就代表数组的地址

```c
int arr[3];
printf("数组名：%p",arr);
printf("下标是0：%p",&arr[0]);
```

# 数组的长度计算

```c
sizeof(数组名）;//数组占用总的字节数
--------------------------------
int arr[]={1,2,3,4,5,6,7};
int len = sizeof(arr) / sizeof(arr[0]);
for(int i=0;i<len;i++){
  printf("arr[%d] = %d\n",i,arr[i]);
}
 /*把元素占用的字节数也用sizeof计算
 sizeof(arr) / sizeof(元素类型）;
 或
 sizeof(arr) / sizeof(arr[0]); 
```

# 数组作为函数的参数

- 1、声明

在函数的小括弧中声明一个数组

```c
void testArray(int  arr[3]){}
```

2、调用

调用时传递一个数组，传入数组的类型和参数数组的类型一致

```c
int shuZu[] = {1,2,3};
testArray(shuZu);
```

- 当数组作为函数的参数在传递时会丢数据

所以算不出来这个数组的长度

因为

如果函数的参数是一个数组，声明参数的时候不会创建数组，会声明一个用来存储数组地址的变量（**指针变量**，8个字节）

数组的名字代表数组的地址，把数组的地址传给 用来存储数组地址的变量里面去，所以指针就指向了了这个数组

![image-20210726185055406](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210726185055406.png)

![image-20210726184508293](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210726184508293.png)

- 解决函数内数组的长度对应：

再搞一个参数来传递长度

```c
void testArray(int arr[],int len){//反正参数里的数组是指针，那就不写
    for(int i = 0;i < len;i++){
        printf("%d\n",arr[i]);
    }
}
int main(){
    int shuZu[]={12,34,56};
    testArray(shuZu, 3);
  return 0;
}
```

**如果函数的参数是数组，就得再搞一个数组长度的参数**

```c
void testArray(int arr[],int len){
    for(int i = 0;i < len;i++){
        arr[i] = 100;
    }
}
int main(){
    int shuZu[]={12,34,56};
    testArray(shuZu, sizeof(shuZu)/sizeof(shuZu[0]));
  for(int i = 0;
i < (sizeof(shuZu)/sizeof(shuZu[0]));
      i++){
    printf("%d\n",shuZu[i]);
}
  return 0;
}//最后都打印出100，因为arr[i] = 100;把100给指针变量arr，通过指针变量操作就是在操作指针变量指向的数组
```

![image-20210726192801687](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210726192801687.png)

![image-20210726193353162](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210726193353162.png)

# 双色球

1、1～33随机产生6个不重复的数（一下代码只搞这个）

2、1～16产生一个随机数

```c
//法1
//判断数组中是否有重复的数据
int isContains(int arr[],int len,int key);
int main(int argc,const char * argv[]){
//1、准备长度为6的数组，用来储存已经产生好了的随机数
int redBalls[6] = {0};
//2、产生6个随机数
//如果数组包含产生过的随机数就重新产生，否则就储存进数组
    for(int i = 0;i < 6;i++){
    loop:
        printf("");
        int num=arc4random_uniform(33)+1;
        //判断数组中是否有重复的数据
        int res = isContains(redBalls, 6, num);
        //判断结果
        if(res == 0){
            //不包含，存到数组中
            redBalls[i] = num;
        }
        else{//包含
            goto loop;
    }
}
//打印数据
    for(int i = 0;i < 6;i++)
    {
        printf("%d\n",redBalls[i]);
    }
    return 0;
}
    

int isContains(int arr[],int len,int key){
    for(int i = 0;i < len;i++){
        if(arr[i] == key){
            return 1;
        }
    }
    return 0;
}
//法2----------------------------------
//判断数组中是否有重复的数据
int isContains(int arr[],int len,int key);
int main(int argc,const char * argv[]){
//1、准备长度为6的数组，用来储存已经产生好了的随机数
int redBalls[6] = {0};
//2、产生6个随机数
//如果数组包含产生过的随机数就重新产生，否则就储存进数组
    for(int i = 0;i < 6;){
   
        printf("");
        int num=arc4random_uniform(33)+1;
        //判断数组中是否有重复的数据
        int res = isContains(redBalls, 6, num);
        //判断结果
        if(res == 0){
            //不包含，存到数组中
            redBalls[i] = num;
            i++;
        }
    }
//打印数据
    for(int i = 0;i < 6;i++)
    {
        printf("%d\n",redBalls[i]);
    }
    return 0;
}
    

int isContains(int arr[],int len,int key){
    for(int i = 0;i < len;i++){
        if(arr[i] == key){
            return 1;
        }
    }
    return 0;
}
```

# 数组的排序

- 选择排序：

（由大到小）俩俩比较，第一次找出最大，第二大……

有n个数据，比n-1轮

![image-20210726221027625](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210726221027625.png)

```c
//由大到小排序
int main(){
int arr[] = {12,536,612,5,345,7,5,46,547,2,4,9};
int len = sizeof(arr) / sizeof(arr[0]);
//数组有len个数据，要比len-1次，每循环一次就要完成一轮的比较
for(int i = 0;i < len-1;i++){//外层控制循环轮数
    //每循环一次就要把下标i的元素和之后所有的元素进行比较
    //arr[i]     [i+1]      [len-1]
    for(int j = i+1;j < len;j++){
        if(arr[i]<arr[j]){
            //i在前j在后，i<j，交换位置
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
}
//遍历打印
for(int i = 0;i < len;i++){
    printf("%d\n",arr[i]);
}
    return 0;
}
```

-  冒泡排序 ![image-20210726223939042](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210726223939042.png)

（由大到小）俩俩比较，第一次找出最小，第二小……

有n个数据，轮数n-1

```c
int main(int argc,const char * argv[]){
    int arr[] = {34,545,2,3,4,35,46,5,6};
    //计算数组长度
    int len = sizeof(arr)/sizeof(arr[0]);
    //要比len-1轮
    for(int i = 0;i < len - 1;i++){
        //每i轮内层要比len - 1 - i次
        for(int j = 0;j < len - 1 - i;j++){
            //要比较的数j j+1
            if(arr[j] < arr[j+1]){
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
    for(int i = 0;i < len;i++){
        printf("%d\n",arr[i]);
    }
    return 0;
}
```

- 二分查找法/折半查找 指定数据

要求：数据是有序的

![image-20210726231334297](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210726231334297.png)

```c
//找10在数组里的下标
int main(int argc,const char * argv[]){
int arr[] = {2,4,5,6,8,9,10};
    int len = sizeof(arr)/sizeof(arr[0]);
    int key = 10;
    int min = 0;
    int max = len - 1;
    int mid = len / 2;//第一次二分完成
    //先判断中间的数是不是key，不一样再判断大小，继续二分
    while(key != arr[mid]){
        //判断大小
        if(arr[mid] > key)
        {
            //说明目标数在左边
            max = mid - 1;//把范围缩小
        }
        else if(arr[mid] < key){
            //说明目标数在右边
            min = mid + 1;
        }
        mid = (min + max) / 2;//方便直接继续循环
    }
    printf("下标为%d\n",mid);
    return 0;
}
```

# 数组倒序

1、画图

2、一个一个数看

3、找规律，循环次数，交换数据下标直接的规律

![image-20210727110403134](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210727110403134.png)

```c
int main(int argc,const char * argv[]){
int arr[] = {235,46,7,6,243,54,56,6,76,46,34};
int len = sizeof(arr)/sizeof(arr[0]);
for(int i = 0;i < len/2;i++){
    //交换两个数值的位置
    int temp = arr[i];
    arr[i] = arr[len-1-i];
    arr[len-1-i] = temp;
}
for(int i = 0;i < len;i++){
    printf("%d\n",arr[i]);
}
    return 0;
}
```

# 二维数组概述

- 特点：是一个数组，满足数组的特点

二维数组是一个有行有列(从零开数数）的表格，单元格就是二维数组的元素

每一个元素的下标有2个，横下标，列下标

长度：单元格的个数，行 * 列

```c
元素类型 数组吗【行数】【列数】;
int arrr[3][4];
--------------------------
arr[][2] = 100;
//将100存储到arr第零行，第二列的元素中
---------------------------
  //遍历打印二维数组
  for(int i = 0;i < 行数;i++){
  for(int j = 0;j < 列数；j++){
  arr[i][j];
  }
  }
```

- 行数个数可以是：变量，常量，宏，表达式，0，1，不能是小数，不能是负数
- 初始化

```c
1、1 逐个赋值
  int arr[][4] = {//行数可以省略
  {10,20,30,40},
  {50,60,70,80}
};
1、2 直接横着写
  int arr[][4] = {10,20,30,40,50,60,70,80};//行数可以省略

2、 部分初始化,初始化第一列，其他元素被自动初始化0
  int arr[2][4] = {{10},{20}};
/*10 0 0 0
  20 0 0 0 */

3、 按照顺序初始化,其他元素默认被自动初始化0
  int arr[][4] = {10,20,30,40,50};
/*10 20 30 40
  50  0  0  b 0 */
  //行数可以省略

4、 给指定的行初始化，其他元素默认被自动初始化为0
  int arr[3][4] = {[1] = {10,20,30,40},[2] = {50,60,70,80}};
//指定给第1和第2行进行初始化

5、给指定元素初始化,其他元素默认被自动初始化为0	
  int arr[3][4] = {[0][1] = 20,[1][3] = 60};
```

# 二维数组与内存

- 二维数组本质是一个一维数组，每一个元素都是一个数组

二维数组的每一行就是一个一维数组

![image-20210727161855450](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210727161855450.png)

![image-20210727161829322](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210727161829322.png)

![image-20210727161920029](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210727161920029.png)

![image-20210727161942303](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210727161942303.png)

# 二维数组的地址，行列计算

- 二维数组的地址：

组成这个二维数组的低字节的地址

=

第0行的地址

```c
printf("%p\n",&arr[0][0]);//需要取地址符，取的是变量
printf("%p\n",arr[0];//不需要取地址，第0行就是一个一维数组，数组名就是地址
```

![image-20210727173745134](3%E5%87%BD%E6%95%B0-%E8%BF%9B%E5%88%B6-%E6%95%B0%E7%BB%84.assets/image-20210727173745134.png)

- 长度以及行列计算

求行数： 总的字节数除以每行占用的字节数

```c
int rows = sizeof(arr)/sizeof(arr[0]);
```

求列数：每一行的字节数除以每一个元素的字节数

```c
int cols = sizeof(arr[0])/sizeof(int);
```

# 二维数组与函数

- 如果函数的参数是一个一维数组，在传递的时候可以传递二维数组的行

如果函数的参数是一个二维数组，传进去的是一个指针变量（8个字节）

当二维数组作为函数的参数时，行数可以不写，列数必须写。

- 传递二维数组，一定要给行数，列数

- 传进去的实参二维数组和形参二维数组的**列数**一定要一致

```c
void test(int rows,int cols,int arr[][cols]);
//写参数的时候，先写行数和列数，然后二维数组的列数用参数指定】
```

# 字符数组

- 声明，赋值，取值

```c
char chs[4];
chs[0] = 'a';
chs[2] = 'b';
printf("%c\n",chs[0]);
```

- 遍历

```c
for (int i = 0;i < sizeof(chs);i++){
  printf("%c\n",chs[i]);
}
```

- 字符数组默认值：垃圾值

若初始化个别字符数组元素，剩余的元素就自动成为\0，打印出来什么都没有，ASKII码是0

