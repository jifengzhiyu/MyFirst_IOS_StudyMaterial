# 结构体概述

- 一种类型变量，由多个普通小变量组成

- 创建新的数据类型：创建新类型，没有变量

```c
struct 新类型名字{
  //创建的新类型里面都有哪些变量
  数据类型1 小变量名称1；
  数据类型2 小变量名称2；
};
---------------------------------------
  struct Student
  {
    char* name;
    int age;
    float height;
  };//数据类型的名称是struct Student
```

- 声明新类型变量

变量值有所有 新的类型 所包含的所有小变量

变量的类型是 **strcuct +结构名**

```c
struct 新类型名称 变量名；
  --------------------------
  struct Student stu;
//stu是一个变量名，才会在内存中存在
//声明1个struct Student类型的变量，变量名是stu
```

![image-20210730222522459](5%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.assets/image-20210730222522459.png)

- 批量声明结构体变量

```c
//批量声明变量
struct Student xiaoming,xiaobao,xiaohong;
```

- 特点：每个成员有自己的名字
- 结构体类型命名：首字母大写

- 声明结构类型同时创建结构变量

```c
struct Computer{
  char* cpu;
  int size;
  char* brand;
}iMac,iPro;//结构体变量iMac,iPro
```

- 匿名结构体:结构体类型没有名字,只能在 声明结构类型同时创建结构变量（用得少）

```c
struct{
  char* cpu;
  int size;
  char* brand;
}iMac;
```



# 结构体变量的初始化

- 为结构体变量里面的小变量（成员）初始化

如果没有给成员初始化，就是垃圾值。在声明结构体变量的**同时**只要初始化一个成员，其他成员就会自动被初始化为0。

1、先声明变量，再使用 . 一个个为成员赋值 

```c
结构体变量名称.成员名 = 数据；
  ---------------------
  int main(int argc,const char* argv[]){
    struct Student{
        char* name;
        int age;
        int score;
        float height;
      };
    struct Student stu;
    stu.name = "Jack";
    stu.score = 100;
    stu.age = 17;
    stu.height = 190.1;
    printf("姓名：%s. 年龄：%d.成绩:%d 身高：%.2f\n",
             stu.name,
             stu.age,
             stu.score,
             stu.height
             );
  return 0;
}
```

2、在声明结构体变量的同时，给所有成员初始化

```c
struct Student xiaoMing = {"小明",17,92};
```

只按顺序初始化部分成员

```c
struct Student xiaoMing = {"小明"}
```

指定成员的初始化

```c
struct Student xiaoMing = {.age = 17,.sore = 83};
```

# 结构体类型的作用域

- 一般情况下，结构体类型定义在外面
- 如果定义在函数内部，只能在函数内部使用

# 结构体之间的赋值

- 相同结构体之间可以相互赋值，**值传递**

通过拷贝成员的值，来赋值给目标结构体变量的成员

```c
struct Student{
    char* name;
    int age;
    int score;
};
int main(int argc,const char* argv[]){
    struct Student xiaoMing = {"小明",19,100};
    struct Student xiaoHua = xiaoMing;
    xiaoHua.name = "小花";
    printf("xiaoMing.name = %s\n",xiaoMing.name);
}
```

![image-20210731093406186](5%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.assets/image-20210731093406186.png)

# 结构体数组

- 结构体数组的声明

```c
元素名字 数组名【长度】；
  -------------------------------------------
struct Student{
 char* name;
  int age;
  int score;
};
int main(int argc,const char* argv[]){
  struct Student students[5];
  //数组元素的类型struct Student
  return 0;
}
```

- 结构体数组元素的初始化

1、先声明结构体数组，用下标一个个赋值

用大括号给结构体数组元素赋值时，需要在前面加小括弧（结构体类型）{  };

students[0] = (struct Student){"小明0",12,54};

```c
struct Student{
 char* name;
  int age;
  int score;
};
int main(int argc,const char* argv[]){
  struct Student students[5];
    students[0] = (struct Student){"小明0",12,54};
    students[1] = (struct Student){"小明1",13,57};
    students[2] = (struct Student){"小明2",14,58};
    students[3] = (struct Student){"小明3",15,53};
    students[4] = (struct Student){"小明4",16,55};
    for(int i = 0;i < 5;i++){
        printf("姓名：%s 年龄：%d 成绩:%d\n",
               students[i].name,
               students[i].age,
               students[i].score
               );
    }
  return 0;
}
```

2、在声明结构体数组的同时，对元素进行初始化（按照数组的方法初始化

```c
struct Student students[] = 
{
  {"小明0",11,34},
  {"小明1",13,54},
  {"小明2",14,55},
  {"小明3",15,52},
  {"小明4",17,54}
};
```

- 结构体数组的长度

```c
int len = sizeof(students) / sizeof(struct Student);
```

# 结构体指针

- 结构体指针的声明

取出结构体变量的地址，赋值给指针变量

```c
struct 结构体类型名称* 指针名
  ---------------------------
  struct Student* pStu = &xiaoMing;

```

- 通过指针访问结构体变量

1、

(*结构体指针名).成员

（*pStu）.name = "jack";

```c
struct Student{
 char* name;
  int age;
  int score;
};
int main(int argc,const char* argv[]){
  struct Student xiaoming = {"小明",11,34};
  strct Student* pStu = &xiaoMing;
  （*pStu）.name = "jack";
  （*pStu）.age = 19;
  （*pStu）.score = 99;//.的优先级比*高
  printf("姓名：%s 年龄：%d 成绩:%d\n",
               xiaoMing.name,
               xiaoMing.age,
               xiaoMing.score
               );
```

2、指针名称 -> 成员

```c
pStu->name = "jack";
  pStu->age = 19;
  pStu->score = 99;
```

# 结构体嵌套

- 一个人信息：身高，体重，姓名，出生日期（又是一个人结构体）

在为结构体定义成员的时候，发现一个成员也需要许多变量组成，就再声明一个结构体

```c
struct Date{
  int year;
  int month;
  int day;
}
struct Person{
  char* name;
  int age;
  double money;
  struct Date birthday;
}
int main(){
  struct Person xiaoMing = {"小明",18,5.6,{199,2,3}};
```

![image-20210731104200455](5%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.assets/image-20210731104200455.png)

# 结构体与函数

- 结构体作为函数参数:**值传递**

```c
struct Student{
 char* name;
  int age;
  int score;
};
void test(struct Student stu)//判断一个学生的成绩是否及格
{
  if (stu.score >= 60){
    printf("%s恭喜及格\n",stu.name);
  }else{
    printf("%s你完蛋了\n",stu.name);
  }
}
int main(){
  struct Student s1 = {"小明",18,97};
  test(s1);
  return 0;
}
```

如果在函数内想更改，传值回去

```c
struct Student{
 char* name;
  int age;
  int score;
};
void test(struct Student* stu)//判断一个学生的成绩是否及格
{
  
  stu -> score = 100;
  //stu此时是指针
}
int main(){
  struct Student s1 = {"小明",18,97};
  test(&s1);
    printf("%d",s1.score);
  return 0;
}
```

- 结构体作为函数的返回值

直接返回结构体变量名

```c
struct Student{
 char* name;
  int age;
  int score;
};

struct Student getAStudent(void){
    struct Student s1 = {"Rose",21,100};
    return s1;
}
int main (){
    struct Student s1 = getAStudent();
    printf("%s  %d  %d  \n",s1.name,s1.age,s1.score);
}
```

如果返回结构体地址的话，地址有，地址里面的数据没有（局部变量，离开函数消失）

如果要返回结构体变量的地址（指针）话，要将结构体变量创建在堆区

```c
#include<stdlib.h>
truct Student{
 char* name;
  int age;
  int score;
};

struct Student* getAStudent(void){
   struct Student* p1= calloc(1,sizeof(struct Student));//返回值：void*
  p1->name  = "Rose";
  p1-> age = 10;
  p1-> score = 100;
 return p1;
}
int main (){
    struct Student* s1 = getAStudent();
    printf("%s  %d  %d  \n",s1->name,s1->age,s1->score);
}
```

# 枚举概述

- 变量的值是确定的，只能是指定几个值中的一个，不能随便取值

自己定义具备限定取值的类型

- 枚举：支持程序员创建一种数据类型，该类型变量的值被限定
- 创建类型

```c
enum 新类型名称{
  限定取值1，//0
    限定取值2，//1
    限定取值3//2（/枚举值/枚举项）
};
------------------------------
  enum Direction{
  DirectionE,DirectionS,DirectionW,DirectionN};//新的类型enum Direction，只能存储其中指定的任意一个人
```

- 声明变量

```c
enum 枚举类型名称 变量名;
-----------------------------
  enum Direction dir = E;//dir存储的是E这个枚举值所对应的数0
//等价于enum Direction dir = 0;
printf("%d\n",dir);
```

- 枚举的作用域：函数内部；想随地访问，否则可以创建在外面

- 每个枚举值/枚举项都有一个对应的整形数：从0开始依次递增

但可以手动指定每一个枚举值对应整形的数

```c
  enum Direction{
      DirectionE = 10,
       DirectionS = 20,
       DirectionW = 30,
       DirectionN = 40};
    enum Direction dir = E;
    printf("%d\n",dir);
```

枚举变量中真正存储的是 枚举值对应整形的数

用%d输出：没有办法打印枚举值（只能自己写判断，如果枚举值对应的数是0，打印啥）

- 无论是什么类型的枚举变量都是4个字节（int整形变量）
- 一般赋值枚举值，而不是整形数字
- 枚举类型名称的命名：每一个单词的首字母大小 Direction

枚举值的命名：枚举类型的名称 加 自己的名称 DirectionW(以枚举类型的名称开头)

# typedef

- type define类型定义：为已经存在的数据类型取一个别名，使用别名来使用类型

```c
typedef 已经存在的数据类型 别名；
  ---------------------------
  typedef int it;
//给int类型起别名it
```

- 使用情况：当数据类型很长时 unsigned long long int ，枚举类型，结构体类型
- 一般typedef声明在函数外面
- 类型定义结构体

![image-20210731122619445](5%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.assets/image-20210731122619445.png)

可以在typedef的同时创建一个新的数据类型 并为其取别名

- 类型定义枚举类型

![image-20210731153437113](5%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.assets/image-20210731153437113.png)

# 学生系统（部分）

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define NUM 100

/*
 学生信息：编号，姓名，年龄，性别，成绩
 默认10个同学信息（结构体数组）
 业务流程：
 while(1){
 1、显示操作菜单，接收选择
 2、判断选择，根据选择做事情
 }
 */

//性别枚举
typedef enum{
    GenderMale,
    GenderFemale
}Gender;

typedef struct{
    int id;
    char* name;
    int age;
    Gender gender;
    int score;
}Student;

//结构体数组，存储10个学生信息
Student students[NUM] = {
    {1,"jack1",11,GenderFemale,10},
    {2,"jack2",12,GenderFemale,20},
    {3,"jack3",13,GenderMale,30},
    {4,"jack4",14,GenderFemale,40},
    {5,"jack5",15,GenderMale,50},
    {6,"jack6",16,GenderMale,60},
    {7,"jack7",17,GenderFemale,70},
    {8,"jack8",18,GenderMale,80},
    {9,"jack9",19,GenderFemale,90},
    {10,"jack10",10,GenderMale,100}
};

//显示操作菜单，接收用户选择
int shwMenu(void);
//查询学生
void query(void);
//新增学生
void addStudent(void);
//删除学生
void deleteStudent(void);
//修改学生
void modifyStudent(void);
//显示查询的二级菜单，返回用户选择
int showQueryMenu(void);
//查询所有学生信息
void queryAll(void);
//根据编号查询
void queryById(void);
//根据姓名查询
void queryByName(void);
//根据年龄查询
void queryByAge(void);
//根据性别查询
void queryByGender(void);
//根据成绩查询
void queryByScore(void);
//数组中真正存储信息的长度
int realLength = 10;

int main(int argc,const char* argv[]){
    while(1){
        // 1、显示操作菜单，接收选择
        int userSelect = shwMenu();
        //判断选择，根据选择做事情
        switch (userSelect) {
            case 1:
                //查询学生
                query();
                break;
            case 2:
                //新增学生
                addStudent();
                break;
            case 3:
                //删除学生
                deleteStudent();
                break;
            case 4:
                //修改学生
                modifyStudent();
                break;
            default:
                //退出程序
                break;
        }
    }
    return 0;
}

//显示操作菜单，接收用户选择
int shwMenu(void){
    //显示菜单
    printf("********************************************\n");
    printf("*            请使用学生管理系统                *\n");
    printf("*               1、查询学生                  *\n");
    printf("*               2、新增学生                  *\n");
    printf("*               3、删除学生                  *\n");
    printf("*               4、修改学生                  *\n");
    printf("*               5、退出系统                  *\n");
    printf("********************************************\n");
    //接收用户选择
    printf("请输入你的选择：");
    int userSelect = 0;
    scanf("%d",&userSelect);
    //将用户的选择返回
    return userSelect;
}

//查询学生
void query(void){
    //1、显示查询的二级菜单，接收用户选择
    int userSelect = showQueryMenu();
    //2、根据选择，做出查询
    switch (userSelect) {
        case 1:
            //查询所有
            queryAll();
            break;
        case 2:
            //根据编号查询
            queryById();
            break;
        case 3:
            //根据姓名查询
            queryByName();
            break;
        case 4:
            //根据年龄查询
            queryByAge();
            break;
        case 5:
            //根据性别查询
            queryByGender();
            break;
        case 6:
            //根据成绩查询
            queryByScore();
            break;
        default:
            break;
    }
}
//新增学生
void addStudent(void){
    printf("请输入新增的学生姓名:");
    char name1[10];
    rewind(stdin);
    fgets(name1,10,stdin);
    //三个参数，第一个，要将字符串存储到哪一个数组中，第二个，最多接收多少个长度(写的减1个）的字符串，第三个，指定流，stdin 标准输入流
    size_t len = strlen(name1);
    //得到储存在字符数组中字符串的长度
    if(name1[len - 1] == '\n'){
        name1[len - 1] = '\0';//消除用户干扰
    }////因为数组给指针赋值，数组离开函数后清零，所以开辟一个堆区变量
    char* name = calloc(len + 1,sizeof(char));//向堆内存中申请连续的几个字节空间 sizeof(char));
    strcpy(name, name1);
    //向堆内存中申请连续的几个字节空间 sizeof(char));
    printf("请输入新增的学生年龄:");
    int age = 0;
    rewind(stdin);
    scanf("%d",&age);
    printf("请输入新增的学生性别: 0--->男 1---->女");
    int gender = 0;
    rewind(stdin);
    scanf("%d",&gender);
    printf("请输入新增的学生成绩:");
    int score = 0;
    rewind(stdin);
    scanf("%d",&score);
    //创建结构体变量，将其存放在大数据里面
    Student stu = {students [realLength - 1].id + 1,
        name,age,gender,score};
    students[realLength] = stu;
    realLength++;
}
//删除学生
void deleteStudent(void){
    //1、输入删除学生的编号
    printf("请输入要删除学生的编号：");
    int id = 0;
    scanf("%d",&id);
    //2、找到要删的下标
    int deletIndex = -1;
    for(int i = 0;i < realLength;i++){//如果删除最后一个，就进不了这个循环
        if(students[i].id == id){
            deletIndex = i;
            break;
        }
    }
    if(deletIndex == -1){
        printf("你输入的编号有误：");
        return;//结束函数
    }
    //3、将编号后面的元素挨个往上顶,将每一个元素的值赋值给前一个元素
    for(int i = deletIndex + 1;i < realLength;i++){
        students[i - 1] = students[i];
    }
    realLength--;
}
//修改学生
void modifyStudent(void){
    
}
//显示查询的二级菜单
int showQueryMenu(void){
    //显示查询二级菜单
    printf("********************************************\n");
    printf("*           欢迎使用学生管理系统               *\n");
    printf("*           1、查询所有学生信息                *\n");
    printf("*           2、根据编号查询                   *\n");
    printf("*           3、根据姓名查询                   *\n");
    printf("*           4、根据年龄查询                   *\n");
    printf("*           5、根据性别查询                   *\n");
    printf("*           6、根据成绩查询                   *\n");
    printf("********************************************\n");
    //接收用户选择
    printf("请输入查询编号：");
    int userSelect = 0;
    scanf("%d",&userSelect);
    //将用户的选择返回
    return userSelect;
}

//查询所有学生信息
void queryAll(void){
    printf("编号\t姓名\t\t年龄\t性别\t成绩\n");
    for(int i = 0; i < realLength;i++){
        printf("%d---%s---%d---%s---%d\n",
               students[i].id,
               students[i].name,
               students[i].age,
               students[i].gender == GenderMale ? "男" : "女",
               students[i].score
               );
    }
}
//根据编号查询
void queryById(void){
    
}
//根据姓名查询
void queryByName(void){
    
}
//根据年龄查询
void queryByAge(void){
    
}
//根据性别查询
void queryByGender(void){
    
}
//根据成绩查询
void queryByScore(void){
    //1、让用户输入最小成绩
    //2、让用户输入最大成绩
    int min = 0,max = 0;
    printf("请输入最小成绩和最大成绩，使用空格分隔：");
    scanf("%d%d",&min,&max);
    //3、打印出范围中的学生信息
    for(int i = 0;i < realLength;i++){
        if(students[i].score >= min && students[i].score <= max){
            printf("%d---%s---%d---%s---%d\n",
                   students[i].id,
                   students[i].name,
                   students[i].age,
                   students[i].gender == GenderMale ? "男" : "女",
                   students[i].score
                   );
        }
    }
}

```

# 预处理概述

- 特点

预处理指令以#开头

在编译之前执行

预处理指令后面没有；

- ![image-20210731214349760](5%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.assets/image-20210731214349760.png)

![image-20210731215055047](5%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.assets/image-20210731215055047.png)

链接函数，把使用函数实现的地方做一个标记

链接完成，形成 XX.out 文件，可以直接运行

- 预处理指令分类

1、文件包含指令#include

2、宏定义：把一段代码定义为一个标识，使用标识来使用代码

3、条件编译指令：之编译指定的C代码二进制指令

# 宏定义

- 把一段代码定义为一个宏名，使用宏名来使用代码

```c
# define 宏名 宏值
#define N 10
----------------------------------------------
  int a = N + 1;
```

- 原理：在预编译的时候，执行预处理指令，把所有使用宏名的地方替换成宏值（宏替换/宏代换）

- 注意

1、宏值可以时任意东西,在定义宏的时候不会检查语法，会把宏值原封不动地替换(不是替代宏值的结果)

```c
#define N 10+3+2
int a = N + 1;
//int a = 10 + 3 + 2 + 1
```

2、如果宏值包括1个变量名，在使用宏之前一定要保证变量存在

3、无法通过赋值符号为宏改值（宏根本就不是变量）

```c
#define N 12;
N = 10;
//报错
```

4、宏可以定义在函数的内部，可以定义在函数外部（从定义宏的地方到后面的所有地方都可以使用，哪怕是大括号外部）

5、如果在字符串中出现宏名，不会进行宏替换

6、宏的层层替换：宏值当中有其他宏名

```c
#define PI 3.14
#define R 5.1
#define AREA PI * R * R//3.14*5.1*5.1,原封不动
```

7、宏值可以是指令，可以是数据类型

#define 和 #typedef

1、#define是预处理指令，#typedef是C代码（在运行时才会执行）

2、#define可以给任意代码取名，#typedef只给类型取名

```c
#define P printf
#define D "%d"
int main(){
  int a = 2;
  P(D,a);
  return 0;
}
  --------------
    #define STRING char*
    int main(){
    STRING str = "jack";
    return 0;
  }
```

- 解除宏指令：让指定的宏提前失效

```c
#undef 宏名
------------------
  #define N 12
  #undef N
```

# 带参数的宏

- 在宏值中，可以使用参数

如果宏有参数，必须在使用宏的时候给宏的参数传递，**给的什么传递的什么，并不是给变量传值**

```c
# define 宏名（参数名）宏值
宏名（参数值）；
  -------------------------------
  #define N(a) a + a + a
  int main(){
  int i = N(10);//10*10*10原封不动
```

![image-20210801104621013](5%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.assets/image-20210801104621013.png)

- 特点：

1、宏不是函数，参数不需要加类型

2、#define 空格 宏名 空格 宏值

3、与函数相似，但是宏值一旦换行就认为宏定义结束了

# 条件编译指令

- 预处理指令，预编译执行

- 作用：让编译器在编译的时候，编译指定部分的代码

在预编译的时候，如果条件成立，才会把代码编译成二进制指令

```c
#if 条件
C代码
#endif
-----------------------------------
  #define N 20
  int main(){
  #if N == 10
  printf("111\n");
  #endif
  printf("222\n");
  return 0;
}
```

```c
#if 条件
C代码；
#elif 条件
C代码；
#elif 条件
C代码；
#else
C代码；
#endif
-------------------------------------
  #define N 20
  int main(){
  #if N > 0
  printf("aaa\n");
  #elif N > 10
  printf("bbbb\n");
  #elif n > 2-
  printf("ccc\n");
  #else
  printf("ddd\n");
  #endif
 return 0; 
}
```

- 条件编译与if

1、条件编译在预处理执行，IF语句是C代码，编译后执行

2、条件编译指令只编译符合条件的代码，IF编译所有代码

3、条件编译的条件只能是宏

- 注意：**条件编译的条件只能是宏**（它们都在预编译阶段完成）

- Ifdef

如果定义了指定的宏就编译指定的代码

```c
#define N 10
int main(){
  #ifdef N
  C代码；
  #endif
    return 0;
}
-------------------------
#define N 10
int main(){
  #ifdef N
  printf("aaa\n");
  #endif
  printf("bbb\n");
    return 0;
}
```

- Ifndef 如果没有定义指定的宏就编译指定的代码

```c
int main(){
  #ifndef N
  C代码；
  #endif
    return 0;
}
-------------------------
#define N 10
int main(){
  #ifndef N
  printf("aaa\n");
  #endif
  printf("bbb\n");
    return 0;
}
```

- 防止头文件引用多次

一般头文件在创建的时候会自动生成

```c
#ifdef 宏名 宏值
#define 宏名 宏值
代码//引用的头文件
#endif
```

# 用宏来调试

- 用宏来打印变量，进行调试。调试之后改变宏值，不需要删除调试代码

```c
#define DEBUG 1//调试结束修改DEBUG的宏值就行
#if DEBUG == 1
    #define LOG(val1,val2) printf(val1,val2)
#else
    #define LOG(val1,val2)
#endif

int main(){
    int num = 10;
    LOG("num = %d\n",num);
    return 0;
}
```

# static extern关键字

- static extern关键字，用来修饰变量和函数**实现的时候可以不用关键字**

- static可以修饰局部变量，extern不能修饰局部变量

如果局部变量被static修饰，就是静态变量

静态变量存储在常量区，函数执行完毕，静态变量不会被回收。第二次使用该静态变量的时候，声明静态变量语句直接略过，直接使用静态变量的值

```c
void test(void){
    static int num = 0;
    num++;
    printf("num = %d\n",num);
}
int main(){
    test();
    test();
    test();
    return 0;
}
```

![image-20210801150531671](5%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.assets/image-20210801150531671.png)

````c
int num;//定义
int main(){
  printf("%d",num);
  return 0;
}
int num = 10;//声明
//打印10
````

![image-20210801150844300](5%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.assets/image-20210801150844300.png)

- 分模块开发时：

1、全局变量的声明在.h文件中，实现在.c文件中

2、如果将全局变量定义在模块中，就必须用static或extern修饰

如果用extern修饰，这个模块中的全局变量就可以跨模块访问

如果用static修饰，这个模块中的全局变量**只能**在当前模块中访问

- 修饰函数

如果函数被extern修饰，可以跨模块使用（如果函数没有关键字，默认extern）

如果函数被static修饰，无法跨模块使用，只能**只能**在当前模块中使用

# 数据类型

1、基本数据类型：int,double,float,char

2、构造类型：数组，结构体，枚举

3、指针

4、void空类型

5、typedef定义类型



