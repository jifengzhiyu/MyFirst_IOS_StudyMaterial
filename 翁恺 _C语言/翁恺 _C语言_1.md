



<[翁凯C语言_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili](https://www.bilibili.com/video/BV19W411B7w1)>

# 1.1.1 计算机和编程语言

- **程序**是计算机指令的有序集合，是算法用某种程序设计语言的表述，是算法在计算机上的具体实现。

- 用编程语言命令计算机

- 计算机做的都是计算，计算的步骤就是**算法**

算法是解决问题的步骤；程序是算法的代码实现。

程序=算法+数据结构

# 1.1.2 计算机的思维方式

- **枚举法**： 一个个一个试

- **程序的执行**

**解释**：用一个程序理解你的程序，并执行

有特殊的解释能力

**编译**：用一个程序理解你的程序，并翻译给计算机能懂的，并执行

有确定的运算性能

计算机语言本身没有解释编译之分，只是看哪个常用

C语言一般编译

现在没有什么区别，只是喜好问题 

# 1.2.1 为什么是C

使用率高，基础位置

很多时候是唯一的选择，语言带来的“**库**”大

 其他语言差异很小

# 1.2.2 简单历史

指针是C语言的灵魂

C语言最新版本：1999年C99

#  1.2.3 编程软件

- C语言是工业语言，开发效率高，

日常程序很少用，多练习用

- C语言需要被**编译**才能运行，需要**编辑器**（敲代码），**编译器**（翻译给电脑），或者用**IDE**（集成开发环境，二合一）

# 1.3.1 第一个C程序

```c
#include<stdio.h>
int main() 
 {printf("Hello World!\n"); 
return 0; 
}
```

# 1.3.2 详解第一个程序

- 程序框架:

```c
int main()
{
代码
return 0;
}
```

输出：“”，里面的是**字符串**

**printf**：把引号内容原封不动地输出

换行，空格，无所谓

- **/n**：在输出的结果**后换一行**

- **用英文输入法输入所有**

# 1.3.3 做点计算

- **%d** 原封不动输出

```c
int main()
{
printf("12+34=%d", 12+34);
return 0 ;
}
```

意思是：原封不动呈现“12+34”和12+34的结果

**d,**+d代指的值

- 四则运算：加减乘，括号正常，除/，取余%：5%3 = 2，余数不是商，第一次除尽剩的数字

- //: 表示备注，不参与计算

# 2.1.2 变量定义

- ```int price=0;```

变量的名字：price

变量类型int

初始值：0

 变量的定义：<类型名称><变量名称>；

int price, amount ；定义两个变量

变量的名字：叫作“标识符”，只能由字母、数字、下划线组成，数字不在第一个字符位置上，C语言关键字不能作为标识符

# 2.1.3 变量赋值与初始化

- 赋值：a=b,将b的值赋给a

所有变量在被使用前（在=号右边）应该被附一次值

- 初始化：赋值发生在定义变量时

- <类型名称><变量名称>=<初始值>；

- 赋值多个变量：```int price=0, amount=0;```

- =赋值运算符

有=的式子：表达式

# 2.1.4 变量输入

- 函数：printf：输出（最终显示）， scanf：输入（最终显示）

printf,scanf+（格式字符串）

%d:（后边跟）整数变量

```scanf("%d",&变量)；```

# 2.1.5 常量VS变量

- 会变的：变量

不会变的：常量（也可以定义，方便）

直接写在程序的数字：直接量

- const：修饰符，不变的，const int ，后面的变量用大写表示强调

```c
int main()
{
int amount=100;
int price=0;
prinf("请输入金额（元）：")；
scanf("%d",&price);
printf("请输入票面")；
scanf("%d"，&amount);
int change=amount-price;
printf("找您%d元。"\n,change);
return 0;
}
```

- 多个变量的输入：

```c
int a;
int b;
printf("请输入两个整数) ：");
scanf("%d %d",&a,&b);
printf("%d+%d=%d\n",a,b,a+b);
```

# 2.1.6 浮点数

- 非整数：%f

**有小数点**的数就不是整数，是**浮点数**

计算机里两个整数的运算结果只能是整数

当浮点数和整数放在一起运算时，C会把整数转化成浮点数

- 一种类型：double：可以表示浮点数变量

double类型里，输入```scanf("%lf",&foot)```使用%lf

- 转义序列，反斜杠"\"后面的一个字符原样输出。\ ''  \  "

```c
int main()
{
printf("请分别输入身高的英尺和英寸，"
"如输入\"5 7\"表示5英尺7英寸：");
int foot;
int inch;
scanf("%d %d",&foot,&inch);
printf("身高是%f米。\n",((foot+inch/12.0)*0.3048));
//或者写成12
return0;
}
```

```c
int main()
{
printf("请分别输入身高的英尺和英寸，"
"如输入\"5 7\"表示5英寸7英寸：");
double foot;
double inch;
scanf("%lf %lf",&foot,&inch);
printf("身高是%f米。\n",((foot+inch/12)*0.3048));
return0;
}
```

- 整数：

```int```

```printf("%d")```

```scanf("%d")```

- 浮点数：

```double```

```printf("%f")```

```scanf("%lf")```

# 2.2.1 表达式

- **表达式**：一系列**运算符**和**算子**的组合，用来计算一个值

- **运算符**：计算动作（加减乘除等等），包括=（赋值）

- **算子**：参与运算的值，可以常数可以变量，可以一个方法的返回值（=前后都可以是算子）

- 转化单位

时间差

```c
int hour1,minute1;
int hour2, minute2;
scanf("%d %d",&hour1,&minute1);
scanf("%d %d",&hour2,&minute2);
int t1=hour1*60+minute1;
int t2=hour2*60+minute2;
int t= t2-t1;
printf("时间差是%d小时%d分。"，t/60,t%60);
```

引号里面%d,%lf 等等连写就不放逗号了

# 2.2.2运算符优先级

- 求平均值

```c
int a,b;
scanf("%d %d",&a,&b);
double c=(a+b)/2.0;
prinf("%d和%d的平均值=%f\n",a,b,c);
```

- 优先级：正常，自左向右

- +-取正取负（单目运算，自右向左，只有一个算子）

- a*+b a乘以正数b

a*-b a乘以负数b

- 赋值=也是运算，从右向左结合，a=b=6意味a=(b=6)。赋值优先级四则运算最低（正常理解）a=b+5

- 错误示范：

```c
int a=6;
int b;
int c=1+(b=a);
```

- 不要把赋值在不属于正常运算顺序时单独括起来，强行加入更优先的运算，即不要把右边的等号括上括号

- 计算复利：

1年期利率3.3%，转存三年，求本金x元最终的本息数额

本息合计=x(1+3.3%)^3

```c
int x;
scanf("%d",&x);
double amount=x*(1+0.033)*(1+0.033)*(1+0.033);
printf("%f", amount);
```

C语言还没有次方

# 2.2.3 交换变量

- a=5,b=6,要让两个变量的值交换：

错误：a=b,b=a,结果a,b的值都是6

正确：t=a,a=b,b=t,引入一个中间量（临时变量）

```c
int a=5;
int b=6;
int t;
t=a;
a=b;
b=t;
printf("a=%d,b=%d\n"，a,b);
```

- \n表示换行：这个结果下一行呈现下个结果，要放在双引号或者单引号里面使用。

- 断点：（点绿色的小虫子）让程序停在一行，（该行左边点一下，整行变红）

# 2.2.4 复合赋值和递增递减

- 复合赋值运算符：5个算数运算符+-*/%,加上赋值运算符=，就是复合赋值运算符：+=，-=， *=，/=,%=(两个运算符中间不要有空格)

意思：total+=5就是total=total+5

total*=sum+12就是total=total *(sum+12)

- 先计算=号右边的

- 递增递减运算符++，--：是单位运算符（只有一个算子），且唯一一个算子必须是变量

意思：++：这个变量+1，--：这个变量-1

```count++;```

```count+=1;```

```count=count+1;```

前缀后缀：++，--放在变量前面是前缀形式，放变量后面是后缀形式

a++,是a加1以前的值（不变）,结果之后产生的副作用a的值成了a加1

a=10,a++=10,a=11

++a,是加了1以后的值(+1),结果之后产生的副作用a的值成了a加1

a=10,++a=11,a=11

a--,是a减1以前的值（不变）,结果之后产生的副作用a的值成了a减1

--a,是减了1以后的值(-1),结果之后产生的副作用a的值成了a减1

表达式的值：前缀是加1（减1）以后的，后缀是加1（减1）以前的

```c
int a;
a=10;
printf("a++=%d\n",a++);
printf("a=%d\n",a);
printf("++a=%d\n",++a);
printf("a=%d\n",a);
```

- int加变量可以=值，也可以下一行另起赋值

```int a=10;```

或

```int a;```

```a=10;```

# 3.0.2 第二周习题解析

在 小时分钟（四位数） 中分离小时和分钟：小时分钟（四位数）/100，分离出小时；小时分钟（四位数）%100，分离出剩下的分钟

![image-20210531150450036](%E7%BF%81%E6%81%BA%20C.assets/image-20210531150450036.png)

```c
int shurushijian,jingguoshijian;
scanf("%d %d",&shurushijian,&jingguoshijian);
int shuruxiaoshi= shurushijian/100;
int shurufenzhong= shurushijian%100;
int shurushijian2,jingguoshijian1;
shurushijian2=shuruxiaoshi*60+shurufenzhong;
jingguoshijian1=shurushijian2+jingguoshijian;
int jiaqilaizongshijiandexiaoshi=jingguoshijian1/60;
int jiaqilaizongshijiandefenzhong=jingguoshijian1%60;
int jieguo=jiaqilaizongshijiandexiaoshi*100+jiaqilaizongshijiandefenzhong;
   printf("%d",jieguo);
```

![image-20210531152622701](%E7%BF%81%E6%81%BA%20C.assets/image-20210531152622701.png)

712

712/100=7

712%10=2

712%100=12,12/10=1

或者

712/10=71,71%10=1

2*100+ 1 *10+7=217

```c
int s;
scanf("%d",&s);
int a1=s/100;
int b1=s/10;
int b2=b1%10;
int c=s%10;
printf("%d",c*100+b2*10+a1);
```

![image-20210531161701724](%E7%BF%81%E6%81%BA%20C.assets/image-20210531161701724.png)

无论表现形式是怎样，计算机内部都是二进制

两位十进制：18

二进制：0001 0010 

二进制对应BCD：1 2

16进制：0X12

在题目所给范围内十六进制的数字部分就是BCD

做到：输入整数，输出BCD（这里等于16进制）

18（十进制）换为十六进制

18/16=1

18%16=2

1*10+2=12

```c
int a;
scanf("%d",&a);
int b=a/16;
int c=a%16;
printf("%d",b*10+c);
```

# 3.0.1 做判断

```c
int hour1,minute1;
int hour2,minute2;
scanf("%d%d",&hour1,&minute1);
scanf("%d%d",&hour2,&minute2);
int ih=hour2-hour1;
int im=minute2-minute1;
if(im<0)
{
	im=60+im;
	ih--;
}
printf("时间差是%d小时%d分。\n",ih,im);
```

- **如果：**

**if(条件成立){}**

**大括号里Tab缩进之后打要干的事**

- 大括号里用；

小括号用，

如果小括号的条件成立，就会做出大括号的事情，否则就跳过

# 3.1.2 判断的条件

关系运算：计算两个值之间的关系

![image-20210601160954486](%E7%BF%81%E6%81%BA%20C.assets/image-20210601160954486.png)

！：非，否定

当两个值的关系符合关系运算符的预期时，关系运算的结果是整数1，否则为整数0

```c
printf("%d\n",5==9);
printf("%d\n",5==5);
printf("%d\n",5>=9);
printf("%d\n",5>=5);
```

- 优先级，赋值<(==,!=),<关系运算<算数

7>=3+4,7>=7

# 3.1.3 找零计算器

- 单行注释://(给人看的)

多行注释：/*文字 */ 

```c
int price=0;
int bill=0;
printf("请输入金额：");
scanf("%d",&price);
printf("请输入票面：");
scanf("%d",&bill);
if(bill>=price)
{
	 printf("应该找您：%d",bill-price);   
}
```

输入什么，电脑打出printf做确定，叫作人机交互

# 3.1.4否则的话

- 否则的话：if条件不满足

else{}

```c
int price=0;
int bill=0;
printf("请输入金额：");
scanf("%d",&price);
printf("请输入票面：");
scanf("%d",&bill);
if(bill>=price)
{
	printf("应该找您：%d",bill-price);   
}
else
{
	printf("你的钱不够");
}
```

- 写代码：要让更多的人看懂你写的代码

a,b两个数比较最大值

````c
int a,b;
printf("请输入两个整数");
scanf("%d%d",&a,&b);
int max=0;
if(a>b)
{
   max=a;
}
else
{
    max=b;
}
printf("大的那个是%d",max);
````

# 3.1.5 if语句再探

- if(条件){做的事；}

# 3.2.1 嵌套的if-else

嵌套的判断：if的条件无论满不满足有执行的语句

嵌套使用：

if(条件)

{

​	if(条件1){要做的事;}

​	else{要做的事;}

}

a,b,c找最大值，可以两两比较

```c
int a,b,c;
scanf("%d %d %d",&a,&b,&c);
int max=0;
if(a>b)
{
	if(a>c)
    {
     	max=a;
    }
    else{
        max=c;
    }
}
else
{
    if(b>c)
    {
        max=b;
    }
    else
    {
        max=c;
    }
}
printf("%d",max);
```

在**没有**大括号的前提下，else和它最近的if匹配

if和else的匹配与缩进无关

- 还是if,else前后打大括号

# 3.2.2级联的if-else if

```c
if(game over==o)
{
    if(player2move==2)
	printf("your turn\n");
}
else {printf("game over");}
//else和if(game over==o)匹配
```

分段函数的表示：f(x)=-1;x<0

​                                     0;x=0

​                                     2x;x>0

```c
if(x<0){
    f=-1;}
else if (x==o){
    f=0;}
else{
    f=2*x;}
//else{f=2*x;}  和   else if (x==o){f=0;}匹配
//else if (x==o){f=0;}  和  if(x<0){f=-1;}匹配
```

```c
if(x<0){
    f=-1;}
else if {  
(x==o){
    f=0;}
else{
    f=2*x;}
}
```

单一出口：一系列计算书写时只出现一遍所需要的打印。（就这道题我的理解）

单一出口原则是一个函数里面只有末尾一个return（或者void函数完全没有return而在最后一个语句之后自动返回），**中间没有其他的return语句。**（网上的答案）

# 3.2.3 if-else的常见错误

warning警告：重视

缩进敲Tab

# 3.2.4 多路分支

```c
switch(控制表达式){//控制表达式只能是整数型的结果
case 常量://常量可以是常数，也可以是常数计算的表达式（表达式中所有的数都是常数）
语句
break;
case 常量:
语句
break;
default:
语句
break;
}
//可以有多个case
//所有case不匹配时到default
```

表示：控制表达式的变量的值为case后面小括号里常量的值时，执行该case之下语句

- case小括号里的常量可以是const int定义的变量

  const:关键字const用来定义常量，如果一个变量被const修饰，那么它的值就不能再被改变

常数：一个数值不变的常量

- case表示入口，break表示结束，阻断

![iShot2021-06-14 21.19.22](%E7%BF%81%E6%81%BA%20C.assets/iShot2021-06-14 21.19.22.png)

以十位数为依据判断等级

```c
printf("输入成绩（0—100）");
int grade;
scanf("%d",&grade);
grade/=10;//grade=grade/10   复合赋值
switch(grade){
case 10:
case 9:
printf("A\n");
break;
case 8:
printf("B\n");   
break;
case 7:
printf("C\n");
break;
case  6:
printf("D\n"); 
break;
default:
printf("F\n");
break;
}
```

# 4.1.1 循环

判断四位数及其以下正整数的数位

```c
int x;
int n=1;
scanf("%d",&x);
if(x>999){
    n=4;
}
else if(x>99){
    n=3;
}
else if(x>9){
    n=2;
}
printf("%d\n",n);
//只要出现了else就跟最近上面的含有if的（else if也算）
```

任意范围正整数数位判断：包括0（的话）

逆序数数：从右往左

```c
int x;
int n=0;
scanf("%d",&x);
n++;
x/=10;
while(x>0){
    n++;
    x/=10;
}
printf("%d",n);
```

# 4.1.2 while循环

if一次性，while循环

- while后面大括号的内容是循环体

循环体内要有改变条件的机会（避免无限循环）

- 模拟，使用边界，特殊值带入

# 4.1.3 do-while循环

![image-20210604211716163](%E7%BF%81%E6%81%BA%20C.assets/image-20210604211716163.png)

```c
do{
    循环体语句
}while(循环条件);
```

无论如何，do-while都会执行至少一遍

任意范围正整数数位判断：包括0（的话）

```c
int x;
scanf("%d",&x);
int n=0;
do
{
    x/=10;
    n++;
}while(x>0);
printf("%d",n);
```

或者

```c
int x;
scanf("%d",&x);
int n=0;
if(x>0){
    while(x>0){x/=10,n++;printf("x=%d,n=%d\n",x,n);}
}
else{n=1;}
printf("%d",n);
```

做调试的手段：让程序停下来一步一步运行；或者在步骤中打印下来;或者随便打印，比如printf("hr1");  (hr,hr1,hr2,,,,,,常用)

调试之后需要把调试用的语句注释掉

# 4.2.1 循环计算

如果本应该不变的值在循环体循环中变化了，导致输出不应该变化的值变化了的话，应该在前面新设一个（让它不参与到循环之中）

求log~2~x的值，输入X(多少2的次方是x)

``` c
int x;
int ret=0;
int t=x;
scanf("%d",&x);
while(x>1){
    x/=2;
    ret++;
}
printf("log2 of %d is %d.",t,ret);
```



计数循环:倒计时100，发射

```c
int count=100;
while(count>=0){
    printf("%d\n",count);
    count--;
}
printf("发射！\n");
```

# 4.2.2 猜数游戏

![image-20210604230156600](%E7%BF%81%E6%81%BA%20C.assets/image-20210604230156600.png)



写出程序之前，用文字描述程序的思路

![image-20210605102318814](%E7%BF%81%E6%81%BA%20C.assets/image-20210605102318814.png)

循环条件：a不等于number

**随机数：rand()**

实际使用：

```c
#include<stdlib.h>
#include<time.h>
srand(time(0));
int a=rand();
printf("%d\n",a);
```

**x%n=[0.n-1]的整数**

若定义随机数产生于[1,100]的整数

```c
srand(time(0));
int number=rand()%100+1;
int count=0;
int a=0;
printf("我已经想好了一个1到100之间的数。");
do{
    printf("请猜这个1到100之间的数：);
    scanf("%d",&a);
    count++;
    if(a>number){
        printf("你猜的数大了。\n");
    }
      else if(a<number){
          printf("你猜的数小了。\n");
      }
  }
       while(a!=number);
       printf("太好了，你用了%d次就猜到了答案。",count);
```

# 4.2.3算平均数

![image-20210605113404756](%E7%BF%81%E6%81%BA%20C.assets/image-20210605113404756.png)

![image-20210605113736224](%E7%BF%81%E6%81%BA%20C.assets/image-20210605113736224.png)如果想要加小数点：

原来：

```c
printf("%d",sum/count);
```

加小数点：

```c
printf("%f",1.0*sum/count);
```

```c
int number;
int sum=0;
int count=0;
scanf("%d",&number);
while(number!=-1){
    sum+=number;
    count++;
    scanf("%d",&number);
}
printf("%f\n",1.0*sum/count);
```

衡量程序的方式：容易被理解，简化步骤

# 4.2.4整数逆序

把整数x倒过来输出

```c
int x;
scanf("%d",&x);
int digit;
int ret=0;
while(x>0){
    digit=x%10;
    ret=ret*10+digit;
    //printf("x=%d,digit=%d,ret=%d\n",x,digit,ret);
    //上一句调试用
    x/=10;
}
printf("%d",ret);
```

如果想要把输入整数结尾的0也逆序输出：

```c
int x;
scanf("%d",&x);
int digit;
int ret=0;
while(x>0){
    digit=x%10;
    ret=ret*10+digit;
    //prinftf("x=%d,digit=%d,ret=%d\n",x,digit,ret);
    //上一句调试用
    x/=10;
    printf("%d",ret);
}
```

# 5.1.1 for循环

![image-20210605172544926](%E7%BF%81%E6%81%BA%20C.assets/image-20210605172544926.png)

```c
int n;
scanf("%d",&n);
int fact=1;
int i=1;
while(i<=n){
    fact*=i;
    i++;
}
printf("%d!=%d\n",n,fact);
```

用新学的：

**for循环：**

```c
for(第一个表达式；第二个表达式；第三个表达式){要干的事；}
//第一个表达式：初始条件
//第二个表达式：循环条件
//第三个表达式：循环一轮结束进入下一轮要做的事，再和循环条件比较，若成立才正式进入下一轮
 //可以理解成，一个一个循环出来之后再做第三个表达式
```

for 循环的一般形式为：

for(表达式1; 表达式2; 表达式3){
  语句块
}

它的运行过程为：
1) 先执行“表达式1”。

2) 再执行“表达式2”，如果它的值为真（非0），则执行循环体，否则结束循环。

3) 执行完循环体后再执行“表达式3”。

4) 重复执行步骤 2) 和 3)，直到“表达式2”的值为假，就结束循环。

上面的步骤中，2) 和 3) 是一次循环，会重复执行，for 语句的主要作用就是不断执行步骤 2) 和 3)。

“表达式1”仅在第一次循环时执行，以后都不会再执行，可以认为这是一个初始化语句。“表达式2”一般是一个关系表达式，决定了是否还要继续下次循环，称为“循环条件”。“表达式3”很多情况下是一个带有自增或自减操作的表达式，以使循环条件逐渐变得“不成立”。

```c
int n;
scanf("%d",&n);
int fact=1;
int i=1;
for(i=1;i<=n;i++){
    fact*=i;
}
printf("%d!=%d\n",n,fact);
```

for:计数循环

```c
for(i=0;//初始化
   i<5;//在计数器到达某值之前，重复执行循环体
    i=i+1//每执行一轮循环，对计数器值做调整
   
   ){；}
```

求和：变量初始化0，求积：变量初始化1

如果倒着乘的话：

```c
int n;
scanf("%d",&n);
int fact=1;
int i=1;
for(i=n;i>1;i--){
    fact*=i;
}
printf("%d!=%d\n",n,fact);
```

或者更简化：

```c
int n;
scanf("%d",&n);
int fact=1;
int i=n;
for(//n=n;
    ;//三个表达式可以有空的
    n>1;n--){
    fact*=n;
}
printf("%d!=%d\n",i,fact);
```

**for循环表达式的简化：for(;条件；)**

# 5.1.2 循环的计算和选择

```c
for(i=0;i<n;i++)
```

循环次数是n；

通用法则：循环次数：n - i

循环次数以i的变化次数为准

```c
for(i=0;i<5;i++{
  printf("i=%d",i);
}
    printf("\n最后i=%d\n",i);
```

i=0

i=1

i=2

i=3

i=4

最后i=5

- For循环等价于while循环

```c
for(int i=1;i<=n;i++){
  fact*=i;
}
```

=

```c
int i=1;
while(i<=n){
  fact*=i;
  i++;
}
```

 

- **如何选择三种循环：

 循环表达出来有固定次数：for

必须执行一次do_while

其他while**

# 5.2.1 循环控制

素数：只能被1和自己整除的数 1，3，5，7，11

如何判断输入的素数？

判断x可以被2，3，4，，，，x-2整除

明显递增用for

```c
int x;
scanf("%d",&x);
int i;
int isPrime=1;//x是素数
for(i=2;i<x;i++){
  if(x%i==0){
    isPrime=0;//证假用0，证真用1
    break;//遇到就跳出任何循环
  }
} 
if(isPrime==1){
  printf("是素数\n");
}else{
  printf("不是素数\n");
}
```

打断循环：

break：跳出循环

continue：跳过循环这一轮剩下的语句进入下一轮

```c
for(i=2;i<x;i++){
  if(x%i==0){
    isPrime=0;
    continue;
  }
  printf("%d\n",i);//跳过这一行
}
```

# 5.2.2 嵌套的循环

如何输出100以内的素数？

```c
int x;
for(x=1;x<=100;x++){
  int i;
  int isPrime=1；
  for(i=2;i<x;i++){
    if(x%i==0){
      isPrime=0;
      break;
    }
  }
  if (isPrime==1){
    printf("%d",x);
  }
}
```

- 嵌套的循环：循环里面带循环：各种循环

嵌套的循环里面循环条件判断的变量最好不同

- 如果要求列出50个素数的话

**计数：cnt**

想要五个素数一行

```c
int x;
int cnt=0;
for(x=1;cnt<50;x++){
  int i;
  int isPrime=1;
  for(i=2;i<x;i++){
    if(x%i==0){
      isPrime=0;
      break;
    }
  }
  if (isPrime==1){
    cnt++;
    printf("%d\t",x);// \t对齐
    if(cnt%5==0){
      printf("\n");
  }
}
}
```

# 5.2.3离开多重循环

凑硬币：用1角、2角、5角的硬币凑出10元以下的金额

```c
int x;
int one,two,five;
scanf("%d",&x);
for(one=1;one<x*10;one++){
  for(two=1;two < x*10/2;two++){
    for(five=1;five<x*10/5;five++){
      if(one+two*2+five*5==x*10){
        printf("可以用%d个1角加%d个2角加%d个5角得到%d元\n",one,two,five,x);
      }
    }
  }
}
//打印顺序
/*可以用1个1角加2个2角加19个5角得到10元
可以用1个1角加7个2角加17个5角得到10元
可以用1个1角加12个2角加15个5角得到10元
可以用1个1角加17个2角加13个5角得到10元
可以用1个1角加22个2角加11个5角得到10元
可以用1个1角加27个2角加9个5角得到10元
可以用1个1角加32个2角加7个5角得到10元
可以用1个1角加37个2角加5个5角得到10元
可以用1个1角加42个2角加3个5角得到10元
可以用1个1角加47个2角加1个5角得到10元*/
```

Break和 continue只能在其所在的那层循环做

如果只想输出一种结果：

```c
int x;
int one,two,five;
int exit=0;
scanf("%d",&x);
for(one=1;one<x*10;one++){
  for(two=1;two < x*10/2;two++){
    for(five=1;five<x*10/5;five++){
      if(one+two*2+five*5==x*10){
        printf("可以用%d个1角加%d个2角加%d个5角得到%d元\n",one,two,five,x);
        exit=1;
        break;
      }
    }
    if(exit)break;//if(exit==1)break;
  }
  if(exit)break;
}
```

这就是接力break

- **在需要离开整个循环的地方放goto语句：**

**goto 空格 标号;（自己设，课程用out）**

**在需要离开的循环处放上设的标号 冒号（课程中是out:)**

多适用于多重循环，从最内跳到最外时（破坏程序协调性，在别的情况下慎用）

```c
int x;
int one,two,five;
scanf("%d",&x);
for(one=1;one<x*10;one++){
  for(two=1;two < x*10/2;two++){
    for(five=1;five<x*10/5;five++){
      if(one+two*2+five*5==x*10){
        printf("可以用%d个1角加%d个2角加%d个5角得到%d元\n",one,two,five,x);
        goto out;
      }
    }
  }
}
out:
```

# 5.3.1求和

求和：1/1，1/2，1/3……1/n

起点，终点数字明确用for循环

```c
int n;
int i;
double sum=0.0;
scanf("%d",&n);
for(i=1;i<=n;i++){
  sum+=1.0/i;
}
printf("f(%d)=%f",n,sum);
```

改变：1-1/2+1/3-1/4……+1/n

添加变量：sign

```c
int n;
int i;
double sum=0.0;
int sign=1;
scanf("%d",&n);
for(i=1;i<=n;i++){
  sum+=1.0/i;
  sign=-sign;
}
printf("f(%d)=%f",n,sum);
```

# 5.3.2 整数分解

正序分解整数：

输入一个正整数，正序输出它的每一位数字

输入：12345

输出：1 2 3 4 5 

可以打印空格：

```c
printf(" ");
```

```c
//先逆序，再打印（学会用中间变量）
int x;
scanf("%d",&x);
int t=0;
do{
  int d=x%10;
  t=t*10+d;
  x/=10;
}
while(x>0);
x=t;
do{
  int d = x%10;
  printf("%d",d);
  if(x>9){
    printf(" ");
  }
  //每个数字隔开，且最后一个数字之后没有空格
  x/=10;
}while(x>0);
```

输入一个非负整数（可以是0），正序输入它的每一位数字

```c
int x;
scanf("%d",&x);
int mask=1;
int t=x;
while(t>9){
  t/=10;
  mask*=10;//mask代表数位
}
do{
  int d = x/mask;
  printf("%d",d);
  if(mask>=10){
    printf(" ");
  }
  x%=mask;
  mask/=10;
}
while(mask>0);
```

**次方：int mask(自己设定的变量名)=pow(a,b)；**

**mask=a的b次方**

  # 5.3.3 求最大公约数

两个数找最大公约数

枚举法：

```c
int a,b;
int min;
scanf("%d%d",&a,&b);
if(a<b){
  min=a;
}else{
  min=b;
     } 
int ret=0;
int i;
for(i=1;i<=min;i++){
  if(a%i==0){
    if(b%i==0){
     ret=i;
    }
  }
}
printf("%d和%d的最大公约数是%d.",a,b,ret);
```

- 变量表格法：纸上进行演算

- 辗转相除法：

1、若b=0,计算结束，a是最大公约数

2、否则，计算a除以b的余数，让a等于b，b等于刚刚的余数

3、回到第一步

```c
int a,b,t;
scanf("%d%d",&a,&b);
while(b!=0){
  t=a%b;
  a=b;
  b=t;
}
printf("gcd=%d",a);
```

# 6.0.1 习题 给定条件的整数集

![iShot2021-06-16 20.59.23](%E7%BF%81%E6%81%BA%20C.assets/iShot2021-06-16 20.59.23.png)

2-2，3，4，5（连续4个数字）

```c
int a;
scanf("%d",&a);
int i,j,k;
int cnt=0;//计数
i=a;
while(i<=a+3){
  j=a;
  while(j<=a+3){
    k=a;
    while(k<=a+3){
      if(i!=j){
        if(i!=k){
          if(j!=k){
          cnt++;
          printf("%d%d%d",i,j,k);
          if(cnt==6){
            printf("\n");
            cnt=0;
          }else{
            printf(" ");
          }
        }
      }
    }
    k++;
  }
  j++;
}
i++;
}
```

# 6.0.2 水仙花数

![iShot2021-06-16 21.35.05](%E7%BF%81%E6%81%BA%20C.assets/iShot2021-06-16 21.35.05.png)

走遍（比如过一遍所有的三位数）：遍历（遍历100-999）

```c
//计算数位
int n;
scanf("%d",&n);
int first=1;
int i=1;
while(i<n){
  first*=10;
  i++;
}
i=first;
while(i<first*10){
  int t=i;
  int sum=0;
  do{//分离出一个一个数
    int d=t%10;
    t/=10;
    int p=1;//或者int p=d;
    int j=0;//int j=1;
    while(j<n){//对分离出的数做次方
      p*=d;
      j++;
    }
    sum+=p;
}while(t>0);
if(sum==i){
  printf("%d\n",i);
}
i++;
}
```

# 6.0.3 九九乘法表



![iShot2021-06-17 15.30.51](%E7%BF%81%E6%81%BA%20C.assets/iShot2021-06-17 15.30.51.png)

```c
//打印是横着一排一排打印的
//横着变的是j,所以j在内层循环先++   
int n;
scanf("%d",&n);
int i,j;
i=1;
while(i<=n){
  j=1;
  while(j<=i){
    printf("%d*%d=%d",j,i,i*j);//注意顺序
    if(i*j<10){
      printf("    ");//4个空格
    }else{
      printf("   ");//3个空格
    }
    j++;
  }
  printf("\n");
  i++;
}
```

# 6.0.4 统计素数并求和

![iShot2021-06-17 16.32.40](%E7%BF%81%E6%81%BA%20C.assets/iShot2021-06-17 16.32.40.png)  

[m,n]

**初始值一般为0**

```c
int m,n;
int i;
int cnt=0;
int sum=0;
scanf("%d%d",&m,&n);
if(m==1){m=2;}//1不是素数，强行把1剔除
for(i=m;i<=n;i++){//i用作遍历的数
  int isPrime=1;//引入判断素数的变量
  int k;//除数
  for(k=2;k<=i-1;k++){
    if(i%k==0){//判断是不是素数
      isPrime=0;
      break;//一旦不是素数就不用再测试了
    }
  }
  if(isPreime==1){
    cnt++;
    sum+=i;
  }
}
printf("%d %d",cnt,sum);
```

# 6.0.5 猜数游戏

 ![iShot2021-06-17 18.48.30](%E7%BF%81%E6%81%BA%20C.assets/iShot2021-06-17 18.48.30.png)

  ```c
  int number,n;
  int inp;//用户猜的
  int finished=0;
  int cnt=0;//计数
  scanf("%d%d",&number,&n);
  do{
    scanf("%d",&inp);
    cnt++;
    if(inp<0){
      printf("Game Over\n");
      finished=1;
    }else if(inp>number){
      printf("Too big\n");
    }else if (inp<number){
      printf("Too small\n");
    }else{//剩下的可能性就是inp==number
      if(cnt==1){
        printf("Bingo!\n");
               }else if (cnt<=3){
                 printf("Lucy You!\n");
               }else{//剩下的就是cnt>3
                 printf("Good Guess!\n");
               }
               finished=1;
               }
               if(cnt==n){
                 if(!finished){
                   printf("Game Over\n");
                   finished=1;
                 }
               }
               }while(!finished);
  ```

# 6.0.6 求序列前n项和



![iShot2021-06-17 22.17.34](%E7%BF%81%E6%81%BA%20C.assets/iShot2021-06-17 22.17.34.png)

 **int 整数（数学上）的存在范围比double整数（数学上）的存在范围小**

```c
int n;
double dividend,divisor;//分子，分母
double sum=0.0;
int i;
double t;
scanf("%d",&n);
dividend=2;//分子
divisor=1;//分母
for(i=1;i<=n;i++){//i帮助n一个个取数
  sum+=dividend/divisor;
  //后面会把dividend数值改变，所以用一个变量t
  t=dividend;//分子
  dividend=dividend+divisor;
  divisor=t;
}
printf("%.2f\n",sum);
```

# 6.0.7 习题讲解

## 5-1约分最简分式

![iShot2021-06-18 14.04.31](%E7%BF%81%E6%81%BA%20C.assets/iShot2021-06-18 14.04.31.png)

```c
//辗转相除法算最大公约数
int dividend,divisor;
scanf("%d/%d",&dividend,&divisor);
int a=dividend;//分子
int b=divisor;//分母
int t;
      while(b>0){
        t=a%b;
        a=b;
        b=t;
      }
      printf("%d/%d\n",dividend/a,divisor/a);//找出最大公约数对其约分
      
```

## 5-2念数字



![iShot2021-06-18 14.31.41](%E7%BF%81%E6%81%BA%20C.assets/iShot2021-06-18 14.31.41-3997956.png)

![iShot2021-06-18 14.31.41](%E7%BF%81%E6%81%BA%20C.assets/iShot2021-06-18 14.32.02.png)

```c
int x;
scanf("%d",&x);
if(x<0){
  printf("fu ");//fu空格
  x=-x;
}
int mask=1;//数位，以多少个10的次方，表示
int t=x;
while(t>9){//t是两位数
  t/=10;
  mask*=10;
}
do{
  int d=x/mask;//找出最左边的数字
  switch(d){
    case 0:printf("ling");break;
    case 1:printf("yi");break;
    case 2:printf("er");break;
    case 3:printf("san");break;
    case 4:printf("si");break;
    //……
    case 9:printf("jiu");break;
  }
  if(mask>9)printf(" ");//不是一位数，格式要求
  x%=mask;//去除最左边数字
  mask/=10;
}while(mask>0);//把个位数也读出
printf("\n");
```

## 5-3 求a的连续和

![image-20210618223126516](%E7%BF%81%E6%81%BA%20C.assets/image-20210618223126516.png)

```c
//拼装一个数,再求和
int a,n;
scanf("%d%d",&a,&n);
      int sum=0;
      int i;
      int t=0;//a=0也成立
      //0*10+2 2*10+2 (2*10+2)*10
      for(i=0;i<n;i++){
        t=t*10+a;
        sum+=t;
      }
      printf("%d\n",sum);
```

# 6.1.1 c语言有哪些基础数据类型

- c语言是有类型的语言：

c语言的变量必须在使用前定义，确定类型 int（类型） a;

C++,Java对类型更严格

JavaScript,Python,PHP不看重类型，甚至不需要定义

- 类型安全：

强类型：方便发现简单错误

反对强类型：方便逻辑

早期，面向底层多强调类型

![image-20210618225130865](%E7%BF%81%E6%81%BA%20C.assets/image-20210618225130865.png)

逻辑类放在整数类里面

![image-20210618225312996](%E7%BF%81%E6%81%BA%20C.assets/image-20210618225312996.png)

- 输入浮点数：**%lf**

输出浮点数：**%f**

- 整数表达方式：二进制数（自然形成，可以直接二进制加法）

浮点数表达方式：编码（在二进制加法做不了）

![image-20210618225912319](%E7%BF%81%E6%81%BA%20C.assets/image-20210618225912319.png)

一个字节=8个比特

```c
int a;
a=6;
printf("sizeof(int)=%ld\n",sizeof(int));
printf("sizeof(a)=%ld\n",sizeof(a));
```

Sizeof 是静态运算符：不要在sizeof的括号里做运算（这些运算不会做的）

# 6.1.2 整数类型

![image-20210618231146472](%E7%BF%81%E6%81%BA%20C.assets/image-20210618231146472.png)

- CPU：内部有寄存器，REG

RAM内存

CPU和RAM之间有总线相连

- 一台计算机的字长：寄存器是多少宽（多少比特）

32bit：每个RAM可以表示32个比特的数据；从内存里面取数据到CPU，每一次取32个比特

多见 64bit 32biit 

64 bit 32 bit叫做一个字长：寄存器一次可以处理的数据大小（比特）

- 在c语言中，字长表达int=一个寄存器的大小

**一个比特就是二进制1010的一个0或1，一个字节八个比特**

![image-20210618232037107](%E7%BF%81%E6%81%BA%20C.assets/image-20210618232037107.png) 

# 6.1.3 整数的内部表达

- 计算机内部一切都是二进制

所有类型，在乎我们怎么看待它（而不是计算机如何看）

- 如何表达负数

计算时，负号在数字之外（十进制）

![image-20210619103544968](%E7%BF%81%E6%81%BA%20C.assets/image-20210619103544968-4070153.png)

二进制的负数：

表达方案：

补码

![image-20210619111435080](%E7%BF%81%E6%81%BA%20C.assets/image-20210619111435080.png)

二进制1后面8个0是十进制的256：2^8

因为n（8）是这种类型的位数：所以（1）00000000，的1不当它存在

补码的意义：补码（11111111）和原码（00000001， 1）可以加出一个溢出的0

补码可以直接用（可以将负数直接当作纯二进制的数直接参与运算）

![image-20210619113035182](%E7%BF%81%E6%81%BA%20C.assets/image-20210619113035182.png)

# 6.1.4 整数的范围

![image-20210619164506124](%E7%BF%81%E6%81%BA%20C.assets/image-20210619164506124.png)

00000000～11111111:0～255

11111111~100000000是补码：表示-1～-128

11111111纯二进制：255；当作补码看-1

重要的是人怎么看待

![image-20210619165031026](%E7%BF%81%E6%81%BA%20C.assets/image-20210619165031026.png)

- int的范围：-2^(32-1)~2^(32-1)-1

- 所有整数范围：-2^(n-1)~2^(n-1)-1

![image-20210619165557398](%E7%BF%81%E6%81%BA%20C.assets/image-20210619165557398.png)

- unsigned表示这个数不以补码看待，不把它当作负数；只当作0或正整数

但是有时会改变，能够表达正数的范围（能够扩大为00000000～11111111:0～255）

- 类型的范围是循环往复的：

-128～127:127+1=-128；-128-1=127

如何找出int类型最大整数，以及其数位？

```c
int a=0,b=0;
while(++a>0)//当a<0时跳出循环，此时a刚刚过界（成为最小的负数）
printf("int数据类型最大数是：%d\n",a-1);//把过界的a拉回来，就是最大的a
b++;//b=1;
while((a=a/10)!=0){
  b++;
}
printf("int数据类型最大的数的数位是：%d",b);
```

# 6.1.5 整数的格式化

![image-20210619174334049](%E7%BF%81%E6%81%BA%20C.assets/image-20210619174334049.png)

- 所有小于int的，char,short都用相同的方式输出（包括int）：%d

比int大的（long long)用%ld

- ![image-20210619175517988](%E7%BF%81%E6%81%BA%20C.assets/image-20210619175517988.png)

%d输出时表示输出十进制的数字

八进制，十六进制转化成十进制（不需要自己算，可以用计算器）

```c
char c =012;
int i =0x12;
printf("c=%d,i=%d\n",c,i);
//想输出八进制的：%o
//输出十六进制的：%x
```

也可以用作输入：把输入的数字当作几进制地读，再把它解释为10进制的数

![image-20210619180708607](%E7%BF%81%E6%81%BA%20C.assets/image-20210619180708607.png)

十六进制的两位是一个字节（char）

![image-20210619180850042](%E7%BF%81%E6%81%BA%20C.assets/image-20210619180850042.png)

第一句话：2^4=16

第二句话：2^3=8

# 6.1.6 选择整数类型

c语言复杂因为早期需要准确表达计算机的东西

![image-20210620092701468](%E7%BF%81%E6%81%BA%20C.assets/image-20210620092701468.png)

更慢的原因是会从32或64比特中剥夺出需要的比特

# 6.1.7 浮点类型

一个字节8个字长

![image-20210620095250558](%E7%BF%81%E6%81%BA%20C.assets/image-20210620095250558.png)

 浮点一般用double，它的精度和有效范围更大

![image-20210620101700749](%E7%BF%81%E6%81%BA%20C.assets/image-20210620101700749.png)

+-inf：正负无穷大

Nan:不是有效数字

有效数字：7:只有七个数字是有效的（不同的文件上有效数字不同）

![image-20210620105823360](%E7%BF%81%E6%81%BA%20C.assets/image-20210620105823360-4157905.png)

%e:科学技术法

  ![image-20210620110043522](%E7%BF%81%E6%81%BA%20C.assets/image-20210620110043522.png)

科学记数法是一种记数的方法。把一个数表示成a与10的n次幂相乘的形式（1≤|a|<10，a不为分数形式，n为整数），这种[记数法](https://baike.baidu.com/item/记数法/967407)叫做**科学记数法。**当我们要标记或运算某个较大或较小且位数较多时，用科学记数法免去浪费很多空间和时间。

计算器或电脑表达10的幂是一般是用E或e，也就是1.99714E13=19971400000000。

1E-10:    1.0*10^(-10)

```c
double ff=1E-10;
printf(%E,%.16f\n",ff,ff);
//.16f意思是 在小数点之后显示16位（但是这种规定输出小数点后确定位数的输出会 做四舍五入。
//即使是小数点之后无限显示，真正对的数字只限于该类型的有效数位之中
//一般情况下只显示该类型的有效数字(有时会做四舍五入）
```

计算机最终只能用离散的数字表达数字

浮点数存在误差 (a,b的距离 )

计算机无法表达数轴上任意两点之间的无数个数字，面对一个无法完整表示的数字(b)，它只能选择表现靠得比较近的数字（a它所能表示的），这和它的精度有关

 # 6.1.8 浮点的范围与精度

![image-20210621204440073](%E7%BF%81%E6%81%BA%20C.assets/image-20210621204440073.png)

- 一个数除以零是无穷大

正数除以零：正无穷大

负数除以零：负无穷大

- 零除以零：不存在
- 整数不存在无穷大，只能使用浮点数

```c
//一般默认带小数点的字面量是double
//float使用方法：
//加f或F
float a,b,c;
a=1.345f;
b=1.123f;
c=a+b;
if(c==2.468)
  printf("相等\n");
else
  printf("不相等！c=%.10f,或%f\n",c,c);
//显示小数点后10位
```

Float 不要直接==比大小

需要取差的绝对值，小于一个很小的数（比精度小，有效数字）

```c
fabs(f1-f2)<1e-8
  //float 7个有效数字
```

- 浮点数只有一定范围才有有效数字，所以做精确计算的时候慎用

想办法转化成**整数**做运算

- 整数内部表达二进制

浮点数内部是编码表达

# 6.1.9 字符类型：char

- Char (charactor)是最小的整数类型 也是 字符

单引号扩起来单个的字符（char）：‘a'(包括单引号)

用单引号表示字符字面量（不包括单引号）

Printf,sacnf:%c,字符的输出

- 字面量

```c
int a = 10; // 10为int类型字面量
char a[] = {"Hello world!"} // Hello world 为字符串形式字面量
```

- 每个字符计算机都有对应的整数

```c
//定义字符
char a='x';
printf("a=' %c' ",a);
//定义整数
char a=2;
printf("a=%d",a);
```

```c
char c;
scanf("%c",&c);//读入的是字符 1
printf("c=%d\n",c);//作为整数 49
printf("c='%c'\n",c);//作为字符 '1'
```

```c
int i;
char c;
scanf("%d",&i);//读入的是整数 49
c=i;
printf("c=%d\n",c);//49
printf("c='%c'\n",c);//'1'
//c语言的编码是ASC||
//'1'的编码是49，所以当c==49时，代表'1'
```

- 打印时如果没给字符加单引号，就只会打印出字面量，没有单引号

- 空格字符的编码是32： ' '==32

所以连读的时候不加空格：scanf("%d%c",a,b);

![image-20210621221805393](%E7%BF%81%E6%81%BA%20C.assets/image-20210621221805393.png)

排列：0～9 依次排列

![image-20210621222033580](%E7%BF%81%E6%81%BA%20C.assets/image-20210621222033580.png)

# 6.1.10 逃逸字符

逃逸字符：

反斜杠：  \ "字符 \ "（中间夹着的是一个字符）

![image-20210622081139691](%E7%BF%81%E6%81%BA%20C.assets/image-20210622081139691.png)

打印出来是：“5 7”

如果没有反斜杠，默认最近的两个双引号之间是一个字符串

![image-20210622081308942](%E7%BF%81%E6%81%BA%20C.assets/image-20210622081308942.png)

- 程序运行时在一个黑色的窗口，叫做终端（一个程序shell）来执行我们写的程序
- 不同的shell会对不同的控制字符做出不同的反应

```c
printf("123\bA\n456\n");
//打印12A
//456
```

- 在XCode的控制台框中\a、\b和\r都是没法输出的。

![image-20210622083409435](%E7%BF%81%E6%81%BA%20C.assets/image-20210622083409435.png)

按键tab（\t)的意思是在行当中**固定**的位置，而不是固定大小的字符数量

```c
 printf("123\t456\n");
 printf("12\t456\n");
//打印
//123	456
//12	456
```

- 对于回车换行（\n\r），一般就用换行/n

# 6.1.11 类型转换，在不同类型中转换

![image-20210622085135979](%E7%BF%81%E6%81%BA%20C.assets/image-20210622085135979.png)

![image-20210622085207310](%E7%BF%81%E6%81%BA%20C.assets/image-20210622085207310.png)

- scanf需要得到确定的类型 

- 强制类型转换一般要往小的类型转换：（类型的名字）值 

（int)10.2:把double转换成int

注意范围能否表达

只是从那个变量计算出了一个新的类型的值，它并不改变那个变量，无论是值还是类型都不改变。

```c
int i=12345;
short s=(short)i;
printf("%d\n",i);
//结果：12345
```



- **浮点数，默认为double类型，后面加f表示float类型浮点常数！**

- 强制类型转换的优先级高于四则运算

```c
double a=1.0;
double b=2.0;
int i=(int)a/b;//把a的类型改为int
int i=(int)(a/b);//把a/b的值的类型转化为int
```



# 6.2.1 逻辑类型

bool类型

![image-20210622093100919](%E7%BF%81%E6%81%BA%20C.assets/image-20210622093100919.png)

```c
bool b=6>5;
bool t=true;//true,false都可以，结果不变
t=2;//任何数都可以
printf("%d\n",b);
//打印1
//实际上dool的类型是一个整数
```

# 6.2.2 逻辑运算

![image-20210622165105137](%E7%BF%81%E6%81%BA%20C.assets/image-20210622165105137.png)

 ![image-20210622165410691](%E7%BF%81%E6%81%BA%20C.assets/image-20210622165410691.png)

- 4<x<6结果是1:

4<x:结果只能是0或1

0或1<6:结果是1

正确应该是蓝色的

![image-20210622165618073](%E7%BF%81%E6%81%BA%20C.assets/image-20210622165618073.png)

- !age<20就是age>=20

- 运算级 **!>&&>||**
- ![image-20210622170611598](%E7%BF%81%E6%81%BA%20C.assets/image-20210622170611598.png)
- 赋值运算优先级最低

- 如果多个if相连就可以写成逻辑运算

![image-20210622171217777](%E7%BF%81%E6%81%BA%20C.assets/image-20210622171217777.png)

![image-20210622171348191](%E7%BF%81%E6%81%BA%20C.assets/image-20210622171348191.png)

既然会发生短路，就**不要把赋值，复合赋值组合进表达式**（++，--）

# 6.2.3 条件运算与逗号运算

![image-20210622172510891](%E7%BF%81%E6%81%BA%20C.assets/image-20210622172510891.png)

- ?前：条件

：前：条件满足时的值

；前：条件不满足的值

如果……等于……的话，……，否则……

- 别用嵌套的条件表达式（使程序太复杂，难以理解）

![image-20210622191354913](%E7%BF%81%E6%81%BA%20C.assets/image-20210622191354913-4360435.png)

- **逗号的优先级是所有运算符里最低的**
- i=3+4,5+6;

i=7,赋值优先，5+6就没有算

- i=(3+4,5+6);

i=11,逗号右边的表达式的值作为结果

- 逗号表达式主要在for中使用

