# 11.3.2联合

![image-20210713092421707](%E7%BF%81%E5%87%AFc.assets/image-20210713092421707.png)

- union的每个成员共享一块相同的空间

![image-20210713093407534](%E7%BF%81%E5%87%AFc.assets/image-20210713093407534.png)

```c
//常用方法：来得到一个数内部的各个字节
typedef union{
  int i;
  char ch[sizeof(int)];//ch是数组,char占一个字节。ch每个元素都占据了int的一个字节（所以共有4个元素）
}CHI;
int main()
{
  CHI chi;
  int i;
  chi.i=1234;//（16进制的数是0X04D2）
  for(i=0;i<sizeof(int);i++){
    printf("%02hhX",chi.ch[i]);//输出以字符表达的这个字节，显示2个16进制，如果不到的话补个0
  }
  printf("\n");
  return 0;
}
/*输出D2040000
CUP是X86，是小端（低位在前）
16进制：最右边的是最低位，标记为第0位，向左边一位是第1位
```

# 12.1.1全局变量

![image-20210713100835424](%E7%BF%81%E5%87%AFc.assets/image-20210713100835424.png)

- 区分于本地变量：

本地变量：进这个函数诞生，出来就消失

```c
int f(void);//声明和定义函数即使没有参数也要打上void
int gAll=12;//全局变量，哪里都通用
int main()
{
  printf("in %s gAll=%d\n",__func__,gAll);//__func__指当前这个函数的名字（字符串）
  f();//使用函数没有参数不加void
  printf("agn in %s gAll=%d\n",__func__,gAll);
  return 0;
}
int f(void)//声明和定义函数即使没有参数也要打上void
{
  printf("in %s gAll=%d\n",__func__,gAll);
  gAll+=2;
  printf("agn in %s gAll=%d\n",__func__,gAll);
  return gAll;
}
```

![image-20210713104408214](%E7%BF%81%E5%87%AFc.assets/image-20210713104408214.png)

- 但本地变量一定要初始化

- 全局变量的值 不 应该和另外一个全局变量的值联系在一起

![image-20210713105158558](%E7%BF%81%E5%87%AFc.assets/image-20210713105158558.png)

```c
int f(void);
int gAll=12;
int main()
{
  printf("in %s gAll=%d\n",__func__,gAll);
  f();
  printf("agn in %s gAll=%d\n",__func__,gAll);
  return 0;
}
int f(void)
{
  int gAll=1;//在函数内部定义一个和全局变量同名的本地变量
  printf("in %s gAll=%d\n",__func__,gAll);
  gAll+=2;
  printf("agn in %s gAll=%d\n",__func__,gAll);
  return gAll;
}//存在与全局变量同名的本地变量时，全局变量会被隐藏。
（小范围变量会使大范围同名变量隐藏）
```

# 12.1.2静态本地变量

![image-20210713110044944](%E7%BF%81%E5%87%AFc.assets/image-20210713110044944.png)

```c
int f(void);
int gAll=12;
int main()
{
  f();
  f();
  f();
  return 0;
}
int f(void)
{
  int all=1;
  printf("in %s all=%d\n",__func__,all);
  all+=2;
  printf("agn in %s all=%d\n",__func__,all);
  return all;
}
/*打印
in f all=1
agn in f all=3
in f all=1
agn in f all=3
in f all=1
agn in f all=3
普通变量函数之间结果的数是单独的
```

```c
int f(void);
int gAll=12;
int main()
{
  f();
  f();
  f();
  return 0;
}
int f(void)
{
  static int all=1;
  printf("in %s all=%d\n",__func__,all);
  all+=2;
  printf("agn in %s all=%d\n",__func__,all);
  return all;
}
/*
打印：
in f all=1
agn in f all=3
in f all=3
agn in f all=5
in f all=5
agn in f all=7
静态本地变量第一次进入函数会被初始化，之后再进入就不会被初始化
而
静态本地变量如果没有初始化，默认是0
本地变量第一次进入函数会被初始化，之后再进入反复被初始化
```

![image-20210713111832164](%E7%BF%81%E5%87%AFc.assets/image-20210713111832164.png)

可以看出它是一种生存期为整个源程序的量。

虽然离开定义它的函数后不能使用，但如再次调用定义它的函数时，它又可继续使用，而且保存了前次被调用后留下的值。

因此，当多次调用一个函数且要求在调用之间保留某些变量的值时，可考虑采用静态局部变量。

```c
int f(void);
int gAll=12;
int main()
{
  f();
  return 0;
}
int f(void)
{
  int k=0;
  static int all=1;
  printf("&gAll=%p\n",&gAll);
  printf("&all=%p\n",&all);
  printf("&k=%p\n",&k);
    return 0;
}
/*打印：
&gAll=0x100008010
&all=0x100008014
&k=0x16fdff35c
gAll和all是紧挨的
```

- 作用域指的是描述变量在哪段代码中有效；生命周期指的是变量什么时候被创建，什么时候被释放。

关键字 Static

修饰局部变量：作用域仍然是当前代码块，但生命周期发生变化，生命周期是跟随整个程序。

# 12.1.3全局变量贴士

![image-20210713224421050](%E7%BF%81%E5%87%AFc.assets/image-20210713224421050.png)

- 返回本地变量的地址是危险的，一旦离开函数，本地变量就死了，无法保证它还在那里（并且如果中间运行了别的程序，地址会被下面的程序使用）

返回一个本地变量的地址，让外面的程序继续使用，地址会被下面程序所使用

房子（本地变量离开函数）都收回去了，业主把它租给别人（把地址分配给下面），你还留个钥匙（之前的指针）有啥用

```c
int* f(void);
void g(void);
int main()
{
int *p=f();
  printf("*p=%d\n",*p);//无法保证它还在那里
  g();
  printf("2:*p=%d\n",*p);
   
  return 0;
}
int *f(void)
{
  int i=12;
    printf("i=%p\n",&i);
  return &i;
    
}
void g(void)
{
  int k=24;
  printf("k=%d\n",k);
    printf("k=%p\n",&k);//地址会被下面程序所使用
}
/*打印：
i=0x16fdff33c
*p=12
k=24
k=0x16fdff33c
2:*p=24
```

- 返回全局变量或静态本地变量的地址是安全的，它们的生存期是全局的

![image-20210714115116349](%E7%BF%81%E5%87%AFc.assets/image-20210714115116349.png)

- 反正别用全局变量和静态本地变量

# 12.2.1 宏定义

  ![image-20210714115621502](%E7%BF%81%E5%87%AFc.assets/image-20210714115621502.png)

```c
#define PI 3.1415926
//定义一个符号（一个宏），PI是这个宏的名字，3.1415926是宏的值
//在编译预处理的时候把PI替换成 字符串
//相当于 const double Pi=3.1415926
//定义宏 没有；
//宏 不是C语言
#define FORMAT "%f\n"
int main()
{ 
  printf(FORMAT,2*PI);
 return 0;
}
```

![image-20210714122602046](%E7%BF%81%E5%87%AFc.assets/image-20210714122602046.png)

![image-20210714122724715](%E7%BF%81%E5%87%AFc.assets/image-20210714122724715.png)

 ```c
 #define PI 3.1415926
 #define PI2 2*PI//叠加使用
 #define PRT printf("%f\n",PI);\
 printf("%f\n",PI2)//多行使用
 int main()
 {
   PRT;
   return 0;
 }
 ```

![image-20210714123357640](%E7%BF%81%E5%87%AFc.assets/image-20210714123357640.png)

![image-20210714123630369](%E7%BF%81%E5%87%AFc.assets/image-20210714123630369.png)

- 编译器自带的宏，带着翅膀的宏

__ LINE __(两个下划线)    当前所在行的行号      %d

__ FILE __                        文件名                      %s

__ DATE __                      编译的日期               %s

__ TIME __                      编译的时间               %s

# 12.2.2代参数的宏

![image-20210714181737912](%E7%BF%81%E5%87%AFc.assets/image-20210714181737912.png)

- #define cube(x)((x)* (x)*(x))

()里的参数没有类型，X是个参数，将来会被替换成其他参数

```c
#define cube(x) ((x)*(x)*(x))//#define cube(X) ((X)*(X)*(X))大写X也可以
int main()
{
  printf("%d\n",cube(5));
  // printf("%d\n",((5)*(5)*(5)));
  return 0;
}
```

![image-20210714182707507](%E7%BF%81%E5%87%AFc.assets/image-20210714182707507.png)

![image-20210714182828994](%E7%BF%81%E5%87%AFc.assets/image-20210714182828994.png)

```c
#define MIN(a,b) ((a)>(b)?(b):(a))
/*
表达式1 ? 表达式 2 : 表达式3，其中表达式 1、表达式2、表达式3

计算过程：先求表达式1的值, 如果为真, 则求表达式2 的值并把它作为整个表达式的值。 如果表达式1 的值为假，则求表达式3 的值并把它作为整个表达式的值。
```

![image-20210714183711868](%E7%BF%81%E5%87%AFc.assets/image-20210714183711868.png)

- 但是宏没有任何类型检查，没有定义类型

inline会做参数类型的检查

![image-20210714183925180](%E7%BF%81%E5%87%AFc.assets/image-20210714183925180.png)

# 12.3.1 多个源代码文件

- 源代码（也称源程序）是指未[编译](https://baike.baidu.com/item/编译/1258343)的按照一定的[程序设计语言](https://baike.baidu.com/item/程序设计语言/2317999)规范书写的文本文件，是一系列人类可读的计算机语言指令。

![image-20210714190608343](%E7%BF%81%E5%87%AFc.assets/image-20210714190608343.png)

- 都放在main函数里面太长了，所以分出一些功能（函数）

![image-20210714201212490](%E7%BF%81%E5%87%AFc.assets/image-20210714201212490.png)

- 适用于Xcode 

![image-20210714202258711](%E7%BF%81%E5%87%AFc.assets/image-20210714202258711.png)

# 12.3.2 头文件

![image-20210714203620438](%E7%BF%81%E5%87%AFc.assets/image-20210714203620438.png)

- xcode创建头文件
- ![image-20210714203824250](%E7%BF%81%E5%87%AFc.assets/image-20210714203824250.png)

- 函数原型就是引用的函数语句：如

```c
int max(int a;int b);
```

引用头文件：

```c
#include "max.h"
```

这时候就不需要在使用函数的时候加int max(int a;int b);语句了，只用include就行

![image-20210714204806428](%E7%BF%81%E5%87%AFc.assets/image-20210714204806428.png)

![image-20210714204958678](%E7%BF%81%E5%87%AFc.assets/image-20210714204958678.png)

- 自己给的头文件用双引号

系统给的头文件用尖括号

![image-20210714205230477](%E7%BF%81%E5%87%AFc.assets/image-20210714205230477.png)

- include不是引入库的，只是把头文件原封不动地插入include那一行

![image-20210714205701505](%E7%BF%81%E5%87%AFc.assets/image-20210714205701505.png)

- 检查对外宣称的函数原型（函数使用）和实际的函数（定义的函数）是不是一致：使用定义都要加#include

- 全局变量可以在多个.c文件共享，但是也得告诉全局变量的原型是什么

![image-20210714210209873](%E7%BF%81%E5%87%AFc.assets/image-20210714210209873.png)

- 一个.c文件就是一个编译单元

# 12.3.3 声明

- 在一个编译单元里面定义全局变量，想在所有单元使用：

除了#include，还要声明在项目的某处有一个全局变量（int g ALL）：

在头文件里面

```c
extern int gALL;
```

![image-20210714212330959](%E7%BF%81%E5%87%AFc.assets/image-20210714212330959.png)

- 头文件储存函数（函数原型），变量（extern)的声明

![image-20210714212435425](%E7%BF%81%E5%87%AFc.assets/image-20210714212435425.png)

- 定义（只有）：函数，全局变量     

声明：说一声存在

![image-20210714213534516](%E7%BF%81%E5%87%AFc.assets/image-20210714213534516.png)

![image-20210714213611419](%E7%BF%81%E5%87%AFc.assets/image-20210714213611419.png)

- #include多个头文件，里面如果有2个及其以上的结构声明都会算作重复声明

所以使用标准头文件结构

![image-20210714215723255](%E7%BF%81%E5%87%AFc.assets/image-20210714215723255.png)

```c
//在定义结构的.h文件里面
#ifndef MAX_H_
#define MAX_H_
//如果没有定义MAX_H_（宏）的话，就定义它
#endif//条件编译的结束
//用宏来做条件编译，这时候的宏命名就加__LIST_名字__，来与正常的宏做区分
```

![image-20210714220740890](%E7%BF%81%E5%87%AFc.assets/image-20210714220740890.png)

# 13.1.1 格式化输入输出



![image-20210715094342575](%E7%BF%81%E5%87%AFc.assets/image-20210715094342575.png)

![image-20210715094405489](%E7%BF%81%E5%87%AFc.assets/image-20210715094405489.png)

 ```c
 printf("%+d",9);
 //+9
 printf("%+d",-9);
 //-9
 printf("%d",-9);
 //-9
 //+强制输出+号
 ```

```c
//0填充
printf("%09d\n",123);//共占九个字符，剩余的用0填充
//000000123
```

![image-20210715095656160](%E7%BF%81%E5%87%AFc.assets/image-20210715095656160.png)

```c
printf("%9.2f\n",123.0);
//   123.00
//总共占据9个字符，小数点后2个字符
```

```c
printf("%*d\n",6,123);
//   123
//6是总共占据的字符数
/*
*---->number
.*---->.number
```



![image-20210715100255258](%E7%BF%81%E5%87%AFc.assets/image-20210715100255258.png)

![image-20210715100504054](%E7%BF%81%E5%87%AFc.assets/image-20210715100504054.png)

```c
int num;
printf("%d%n\n",12345,&num);//在%n之前有几个字符，记录在num里面
printf("%d\n",num);
//5
```

![image-20210715101014076](%E7%BF%81%E5%87%AFc.assets/image-20210715101014076.png)

````c
int num;
scanf("%*d%d",&num);//12 24
printf("%d",num);
//24
//跳过了12
````

![image-20210715101244841](%E7%BF%81%E5%87%AFc.assets/image-20210715101244841.png)

```c
int num;
scanf("%i",&num);
printf("%d\n",num);
//输入十进制，8进制，16进制。输出10进制
```



![image-20210715102149410](%E7%BF%81%E5%87%AFc.assets/image-20210715102149410.png)

- Scanf 返回值，读了几个变量进来
- Printf 返回值，输出了多少字符

```c
int num;
int i1=scanf("%i",&num);//查看输入输出返回值
int i2=printf("%d\n",num);
printf("%d:%d\n",i1,i2);
/*
1234(输入） 
1234
1:5（多了一个\n)
```

# 13.1.2 文件输入输出

![image-20210715104224584](%E7%BF%81%E5%87%AFc.assets/image-20210715104224584.png)

```c
终端这么搞
1文件放程序
文件名>文件名（到）：输出到哪个文件
1文件名（到）<文件名：哪个文件输入到1文件
```

![image-20210715110457257](%E7%BF%81%E5%87%AFc.assets/image-20210715110457257.png)

![image-20210715110527022](%E7%BF%81%E5%87%AFc.assets/image-20210715110527022.png)

```c
//针对文本文件n
FILE* fp=fopen("file","r");//fp指针指向FILE。打开一个文件
if(fp){//如果打开了文件
  fscanf(fp,……);
  fclose(fp);
}else{//文件无法打开
  ……
}
```

 ```c
 FILE* fp=fopen("12.in","r");//打开12.in文件 
 if(fp){
   int num;
   fsacnf(fp,"%d",&num);
   printf("%d\n",num);
   fclose(fp);//关掉12,in文件
 }else{
   printf("无法打开文件\n");
 }
 ```

![image-20210715113410285](%E7%BF%81%E5%87%AFc.assets/image-20210715113410285.png)

- 常用w a

# 13.1.3 二进制文件

![image-20210715123955993](%E7%BF%81%E5%87%AFc.assets/image-20210715123955993.png)

![image-20210715150810099](%E7%BF%81%E5%87%AFc.assets/image-20210715150810099.png)

![image-20210715151012968](%E7%BF%81%E5%87%AFc.assets/image-20210715151012968.png)

![image-20210715151135824](%E7%BF%81%E5%87%AFc.assets/image-20210715151135824.png)

- 注册表有所有软件的配置信息

![image-20210715151516825](%E7%BF%81%E5%87%AFc.assets/image-20210715151516825.png)

- 对二进制数据的输入输出

```c
size_t fread(void* restrict ptr,size_t size,size_t nitems,FILE* restrict stream);
/*
void* restrict ptr 一个指针，读或写的内存
size_t size 这块内存大小---->一个结构的大小
size_t nitems有几个这样的内存----->读或写几个结构变量
FILE* restrict stream 文件指针
```

![image-20210715151958812](%E7%BF%81%E5%87%AFc.assets/image-20210715151958812.png)



![image-20210715155526358](%E7%BF%81%E5%87%AFc.assets/image-20210715155526358.png)

  ```c
  fseek(fp,0L,SEEK_END);
  //从最后面开始找这个文件
  ```

![image-20210715163633683](%E7%BF%81%E5%87%AFc.assets/image-20210715163633683.png)

现在基本上不这么来操控数据了

# 13.2.1 按位运算

![image-20210715172659021](%E7%BF%81%E5%87%AFc.assets/image-20210715172659021.png)

- 把整数当做二进制做计算

![image-20210715172845258](%E7%BF%81%E5%87%AFc.assets/image-20210715172845258.png)

![image-20210715172948928](%E7%BF%81%E5%87%AFc.assets/image-20210715172948928.png)

- 每一位逐一进行运算，如果两个数的同一位都是1，这个位上结果才是1

- X & 0XFE使另外一个是的最低位是0

![image-20210715173224275](%E7%BF%81%E5%87%AFc.assets/image-20210715173224275.png)

- FF：11111111

X &  0XFF，截取X数的最后八位

![image-20210715173754424](%E7%BF%81%E5%87%AFc.assets/image-20210715173754424.png)

![image-20210715173902978](%E7%BF%81%E5%87%AFc.assets/image-20210715173902978.png)

- x | 0x01------->x最右边的位数是1

![image-20210715174057342](%E7%BF%81%E5%87%AFc.assets/image-20210715174057342.png)

- 上面一行是按位取反
- 下面一行做减法搞 补码

![image-20210715174903298](%E7%BF%81%E5%87%AFc.assets/image-20210715174903298.png)

```c
unsigned char c=0xAA;//unsigned的作用就是将数字类型无符号化。
printf("c=%hhx\n",c);//hh：单个字符，%X十六进制
printf("~c=%hhx\n",(char)~c);//char希望作为字符（整数）输出 ，取反
printf("-c=%hhx\n",(char)-c);//取负，补码
/*
c=aa
~c=55
-c=56
```



![image-20210715200143274](%E7%BF%81%E5%87%AFc.assets/image-20210715200143274.png)

- 异或可以搞加密

