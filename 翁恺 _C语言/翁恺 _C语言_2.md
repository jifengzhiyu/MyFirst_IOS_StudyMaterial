#  7.1.1 初见函数

![image-20210623184145658](%E7% BF%81%E6%81%BAC.assets/image-20210623184145658.png)

![image-20210623184916289](%E7%BF%81%E6%81%BAC.assets/image-20210623184916289.png)

- 像这样多次复制粘贴只修改很小一部分代码叫做代码复制，不好

一个出错，之后复制的都出错

- 自己做一个自定义函数，然后自己使用

# 7.1.2 函数的定义和调用

![image-20210623190332325](%E7%BF%81%E6%81%BAC.assets/image-20210623190332325.png)

- Void:类型不返回，没有结果

![image-20210623190624264](%E7%BF%81%E6%81%BAC.assets/image-20210623190624264.png)

- sum是函数
- 参数表里面的一个个参数用逗号分割，其中每个参数都是一个类型加一个名字

- 调用函数的时候：

函数名（参数值）

参数值里面：函数定义的参数表有几个参数，就写几个参数，参数类型也对应

![image-20210623191610667](%E7%BF%81%E6%81%BAC.assets/image-20210623191610667.png)

 ![image-20210623184145658](%E7%BF%81%E6%81%BAC.assets/image-20210623184145658.png)

```c
void sum(int begin,int end)
{
  int i;
  int sum=0;
  for(i=begin;i<=end;i++){
    sum +=i;
  }
  printf("%d到%d的和是%d\n",begin,end,sum);
}
int main()
{
  sum(1,10);
  sum(20,30);
  sum(35,45);
  return 0;
}
```

# 7.1.3 从函数中返回

- 如果函数要返回一个结果，用return将结果交给调用它的地方

![image-20210624092124112](%E7%BF%81%E6%81%BAC.assets/image-20210624092124112.png)

return返回的值作为函数内部的结果，可以参与函数外部运算

```c
int max(int a,int b)
{
  int ret;
  if(a>b){
    ret=a;
  }else{
    ret=b;
  }
  return ret;
}
int main()
{
  int a,b,c;
  a=5;
  b=6;
  c=max(10,12);
  c=max(a,b);
  c=max(c,23);
  printf("%d\n",max(a,b));
  return 0;
}
```

- 参数：c=max(max(c,a),5);

(Max(c,a),5)是max的参数

![image-20210624092652161](%E7%BF%81%E6%81%BAC.assets/image-20210624092652161.png)

- 没有返回值的函数

函数头为：void函数名（参数表）

里面不加return

当然也无法对返回值赋值（不返回东西）

# 7.2.1 函数原型

- 函数原型用来告诉编译器这个函数长什么样

![image-20210624093935737](%E7%BF%81%E6%81%BAC.assets/image-20210624093935737.png)

- 为了实现函数在后面，把函数头复制加分号放在头文件下方

这一行就是函数的原型声明

放在下面的自定义函数就是函数的定义

```c
int max(int a,int b);//声明
int main()
{
  int a,b,c;
  a=5;
  b=6;
  c=max(10,12);
  c=max(a,b);
  c=max(c,23);
  printf("%d\n",max(a,b));//ret=6作为max(a,b)的结果输出
  return 0;
}
int max(int a,int b)//定义
{
  int ret;
  if(a>b){
    ret=a;
  }else{
    ret=b;
  }
  return ret;
}

```

![image-20210624095211605](%E7%BF%81%E6%81%BAC.assets/image-20210624095211605.png)

- 函数原型与函数头的区别是多了一个； 

- 函数原型可以不写参数的名字（自己还是写上吧） 

# 7.2.2 函数传递

![image-20210624100442087](%E7%BF%81%E6%81%BAC.assets/image-20210624100442087.png)

- 函数调用的本身也是表达式

函数调用的参数，可以是一个值，表达式 ，给其他函数提供值

c=max(10,12); 字面量

c=max(a,b); 变量

c=max(max(23,45),a);一个函数返回的结果

c=max(23+45,b);一个表达式和变量

![image-20210624101451684](%E7%BF%81%E6%81%BAC.assets/image-20210624101451684.png)

- 还是乖乖地把参数类型匹配了吧

- 错误展示：它本想把a b的数值交换

  **但：c语言在调用函数时，永远只能传值给你函数**

  ```c
  void swap (int a,int b);
  in main()
  {
    int a=5;
    int b=6;
    swap(a,b);
    printf("a=%d b=%d\n",a,b);
    return 0;
  }
  void swap (int a, int b)
  {
    int t=a;//函数里的a,b与上边a,b不一样，相当于新定义两个变量a,b 
    a=b;
    b=t;
  }
  ```

  **每个变量都在自己所在函数的空间里，互不相干（即使名字一样）**

  # 7.2.3 本地变量

  ![image-20210624115211180](%E7%BF%81%E6%81%BAC.assets/image-20210624115211180.png)

   本地变量（局部变量，自动变量）

  ![image-20210624115402644](%E7%BF%81%E6%81%BAC.assets/image-20210624115402644.png)

在大括号外面定义的变量，可以用在大括号里面；大括号里面定义的变量，在大括号外面用不成

![image-20210624120542572](%E7%BF%81%E6%81%BAC.assets/image-20210624120542572.png)

- 本地变量不会被默认初始化

```c
int a, b; //全局变量a和b，有默认值0
int main()
{
int a; //局部变量，本地变量a，没有默认值
a = a+1; //错误，没有初始化a就使用了a的值
return 0;
}
```

本地变量
本地变量：直白地讲，本地变量就是在函数内部定义地变量，也就是我们之前所定义地变量，90%用到地都是本地变量。那么本地变量有什么特点呢？
本地变量特点：只在函数范围内有效，也就是说只有在函数内部才能使用他们。当函数使用完后，本地变量就会被释放掉。
全局变量
全局变量：顾名思义，就是这个变量在本文件中可以被任何函数使用。
全局变量特点：全局变量在程序的全部执行过程中都占用存储单元，而不是仅在需要的时候才开辟单元。

# 7.2.4 函数庶事

当函数没有参数时：

**声明：Void f(void);**

 ![image-20210624122313716](%E7%BF%81%E6%81%BAC.assets/image-20210624122313716.png)

- f((a,b))：先做（a,b）运算，再计算函数，函数计算传入1个参数

f(a,b)：函数计算传入2个参数

- 函数里面不能定义另外的函数：c语言不允许函数的嵌套定义

可以在一个函数里放另外函数的声明，但是不能放定义

- main也是一个函数

可以写成

int main()

or

int main(void)

# 8.1.1 初试数组

-1表示结束，计算用户输入的数字的平均数，并输出所有大于平均数的数

```c
int x;
double sum=0;
int cnt=0;
int number[100];
/*定义新变量，名字是number，是数组
数组的每一个单元都是int
数组可以放100个（可以放多少个值）int*/
scanf("%d",&x);
while(x!=-1){
  number[cnt]=x;
  //number数组cnt位置上的单元等于x
  //cnt是number数组的一个单元(对数组中的元素进行赋值）
  //每循环一次就记录一次x的值(记录所有输入的数字）
  sum+=x;
  cnt++;
  scanf("%d",&x);
}
if(cnt>0){
  printf("%f\n",sum/cnt); 
  int i;
  for(i=0;i<cnt;i++){//遍历整个数组（所有输入的数）
    if(number[i]>sum/cnt){
      printf("%d\n",number[i]);
    }
  }
} 
```

# 8.1.2 数组的使用

![image-20210624193317811](%E7%BF%81%E6%81%BAC.assets/image-20210624193317811.png)

- 类型：数组中每个单元的类型

方括号表示这是一个数组

![image-20210624193639025](%E7%BF%81%E6%81%BAC.assets/image-20210624193639025.png)

![image-20210624193810237](%E7%BF%81%E6%81%BAC.assets/image-20210624193810237.png)

- 数组里面单元是依次紧密排列的

- a[2]=a[1]+6:

把a[1]的值读出来加6，赋值给a[2]

![image-20210624200452894](%E7%BF%81%E6%81%BAC.assets/image-20210624200452894.png)

- [ ]放的可以是变量或常数 

最大的下标是数组的个数-1

![image-20210624201214278](%E7%BF%81%E6%81%BAC.assets/image-20210624201214278.png)

- 下标不要越界：永远在0～个数-1范围内（包括两端）

- 一旦创建数组就不要改变（定义）
- ![image-20210624202814445](%E7%BF%81%E6%81%BAC.assets/image-20210624202814445.png)

# 8.1.3 数组的例子：统计个数

![image-20210624202930883](%E7%BF%81%E6%81%BAC.assets/image-20210624202930883.png)

````c
const int number=10;//用const变量决定数组大小
int x;
int count[number];//定义数组，注意大小
int i;
for(i=0;i<number;i++){//初始化数组，用循环，遍历数组，给每一个元素赋值
  count[i]=0;
}
scanf("%d",&x);
while(x!=-1){
  if(x>=0&&x<=9){//&&且
    count[x]++;//数组参与运算，计数用数做下标
  }
  scanf("%d",&x);
}
for(i=0;i<number;i++){//遍历数组做输出
  printf("%d:%d\n",i,count[i]);
}
````

# 8.2.1 数组运算

- 定义数组变量

1、不初始化数组

定义就结束

2、进行 数组的集成初始化

![image-20210624210147777](%E7%BF%81%E6%81%BAC.assets/image-20210624210147777.png)

- 如果对一个数组的所有元素都初始化（变成0）：

可以

Int count [number]={0};

- 给指定的位置赋值

![image-20210624210701308](%E7%BF%81%E6%81%BAC.assets/image-20210624210701308.png)

 ```c
 int a[10]={
   [0]=2,[2]=3,6
 };
 给0（第一个元素）赋值2，第二个3，第三个6，之后没有赋值的默认0
 //如果没有给大小，那么默认大小就是最后赋值的那个个数
 ```

![image-20210624211253931](%E7%BF%81%E6%81%BAC.assets/image-20210624211253931.png)

- 当初始化一个数组的时候，最后一个数字加上一个逗号

int a[]={2,2,4,5, };

![image-20210624211728710](%E7%BF%81%E6%81%BAC.assets/image-20210624211728710.png)

- 遍历数组：

for循环

```c
for(i=0;i<length;i++){}
```

- 离开循环之后i值正好是无效的下标

```c
/**
找出key在数组a中的位置
@param key 要寻找的数字
@param a 要寻找的数组
@param length 数组a的长度
@return 如果找到，返回其在a中的位置；如果找不到则返回-1
*/
int search (int key,int a[],int length);
int main(void)
{
  int a[]={2,4,6,7,1,3,5,9,11,13,23,14,32};
  int x;
  int loc;
  printf("请输入一个数字:");
  scanf("%d",&x);
  loc=search(x,a,sizeof(a)/sizeof(a[0]));
  if(loc!=-1){
    printf("%d在第%d个位置上\n",x,loc);
  }else{
    printf("%d不存在\n",x);
  }
  return 0;
} 
int search(int key,int a[],int length)
  //数组作为函数参数时，往往必须再用另一个参数来传入数组的大小
  //这里不能用sizeof来计算数组的元素个数
  //在函数定义中给出数组的大小没有意义，应 int a[]
{
  int ret=-1;
  int i;
  for(i=0;i<length;i++){
    if(a[i]==key){
      ret=i;
      break;
    }
  }
  return ret;
}
```

# 8.2.2 数组例子：素数

- 通过循环次数看循环效率
- unix系统：$man sqrt  

搜索sqrt的使用方法

- 判断素数：判断一个数能否被小于其的数素整除

  1、构造数素表

- 在 函数内部构件大括号往往是为了调试

在大括号里面定义自己的变量不会影响到外面的变量

```c
int isPrime(int x,int knownPrimes[],int numberOfKnownPrimes);
int main(void)
{
  const int number=10;//要算出前10个素数
  int prime[number]={2};//2是第一个素数
  int count=1;//规定了第一个元素是2，至少也会有一个元素
  int i=3;//从3开始来测试数字
  
  
  {//设置表头
    int i;
    printf("\t\t\t\t");//固定的t在这个表里，固定的tab
    for(i=0;i<number;i++){//在大括号里面定义自己的变量不会影响到外面的变量，i是独立的
      printf("%d\t",i);//打印出元素对应的位置
    }
    printf("\n");
  }
  
  
  while(count<number){
    if(isPrime(i,prime,count)){//i=3
      prime[count++]=i;//如果发现i是素数，就把i加到prime里面
    }
    
    
    {
      printf("i=%d \tcnt=%d\t",i,count);//该大括号之外的i
     int i;//打印出该数的每个素数信息
     for(i=0;i<number;i++){
     printf("%d\t",prime[i]);
     }
     printf("\n");
    }
    
    
    i++;
  }
  for(i=0;i<number;i++){
    printf("%d",prime[i]);
    if((i+1)%5)printf("\t");//五个素数一行
    else printf("\n");
  }
  return 0;
}
int isPrime(int x,int knownPrimes[],int numberOfKnownPrimes)
{//定义函数
 int ret=1;
 int i;
 for(i=0;i<numberOfKnownPrimes;i++){//遍历所有小于对象数的素数能否将其整除
   if(x%knownPrimes[i]==0){
     ret=0;//ret=1:是素数，ret=0:不是素数
     break;
   }
 }
  return ret;
}

```

![image-20210625114921721](%E7%BF%81%E6%81%BAC.assets/image-20210625114921721.png)

伪代码：

![image-20210625115549953](%E7%BF%81%E6%81%BAC.assets/image-20210625115549953.png)

3、令x的倍数都不是素数（0）

```c
//i是倍数，横向打印
//isPrime[i]是立体打印，与x增值有关
const int maxNumber=25;
int isPrime[maxNumber];
int i;
int x;
for(i=0;i<maxNumber;i++){//初始化使值都是1
  isPrime[i]=1;
}


//for test
printf("\t");//表头，这一数列的数字值
for(i=2;i<maxNumber;i++){
printf("%d\t",i);
}
printf("\n");
//for test


for(x=2;x<maxNumber;x++){//x=1没有意义
  if(isPrime[x]){//isPrime[2*3]=0,【3*2】就不用再计算了
    for(i=2;i*x<maxNumber;i++){//i倍数，但保留2，3，5等等素数作为结果
      isPrime[i*x]=0;
    }
  }
  
  
  //for test
  printf("%d\t",x);
  for(i=2;i<maxNumber;i++){
    printf("%d\t",isPrime[i]);//看看循环的每一轮isPrime[i]怎么变化
  }
  printf("\n");//换一个x才下一行
  //for test
}


for(i=2;i<maxNumber;i++){
  if(isPrime[i]){//isPrime[i]=1，是素数
    printf("%d\t",i);
  }
}
printf("\n");
```

学计算机思维

# 8.2.3 二维数组

- 只有一个下标的数组：一维数组

![image-20210625160131835](%E7%BF%81%E6%81%BAC.assets/image-20210625160131835.png)

第一个数字代表行，第二个数字代表列

![image-20210625160302223](%E7%BF%81%E6%81%BAC.assets/image-20210625160302223.png)

遍历：一维数组一层循环，二维数组两层循环

外面一层遍历行号，里面一层遍历列号

![image-20210625160704200](%E7%BF%81%E6%81%BAC.assets/image-20210625160704200.png)

```c
int a[][5]={
  {0,1,2,3,4},
  {2,3,4,5,6},
};
/*可以看作：
a[0]={0,1,2,3,4};
a[1]={2,3,4,5,6};
*/
```

![image-20210625161206798](%E7%BF%81%E6%81%BAC.assets/image-20210625161206798.png)

- 数组的名字加上其下标就是一个变量：board[i] [j]

```c
   const int size=3;
    int board[size][size];
    int i,j;
    int numOfX;
    int numOfO;
    int result = -1;//-1:没人赢，1:x赢，0:O赢
    //读入矩阵
    for (i=0;i<size;i++){
      for(j=0;j<size;j++){
        scanf("%d",&board[i][j]);
      }
    }
    //检查行
    for(i=0;i<size && result==-1;i++){
      numOfO=numOfX=0;//初始化：numOfO（圈圈的数量）=numOfX（叉叉的数量）=0;
      for(j=0;j<size;j++){//确定i行，看每一列
          if(board[i][j]==1){
          numOfX++;
      }else{
        numOfO++;
      }
    }
    if(numOfO==size){
      result=0;
    }else if(numOfX==size){
      result=1;//再不对了默认没人赢
    }
    }
    
    //检查列
    if(result==-1){//光看行还是无法判断谁赢
      for(j=0;j<size && result ==-1;j++){
        numOfO=numOfX=0;//初始化
        for(i=0;i<size;i++){//确定j列，看每一行
          if(board[i][j]==1){
            numOfX++;
          }else{
            numOfO++;
          }
        }
        if(numOfO==size){
          result=0;
        }else if(numOfX==size){
          result=1;
        }
      }
    }
    //检查对角线
    numOfO=numOfX=0;//初始化
    for(i=0;i<size;i++)//for(j=0;j<size;j++)也可以，只是需要一个限定循环的条件
    {
      if(board[i][i]==1){
        numOfX++;
      }else{
        numOfO++;
      }
    }
    if(numOfO==size){
      result=0;
    }else if(numOfX==size){
      result=1;
    }
    //查看反对角线board[2][0]  [1][1]  [0,2]
    numOfO=numOfX=0;//初始化
    for(i=0;i<size;i++){
      if(board[i][size-i-1]==1){
        numOfX++;
      }else{
        numOfO++;
      }
    }
    if(numOfO==size){
      result=0;
    }else if(numOfX==size){
      result=1;
    }
    printf("%d",result);
```

# 9.1.1取地址运算

![image-20210625193357651](%E7%BF%81%E6%81%BAC.assets/image-20210625193357651.png)

- c语言的变 量都是放在内存里，放在哪里就会有一个地址

运算符&：把变量的地址拿出来告诉你

- %p：将值作为**地址**输出

```c
int i=0;
printf("%p\n",&i);
 //&i  i必须是变量
```

- 定义变量的地址，分配内存，自上（地址高）向下（地址低）分配
- ![image-20210625194039494](%E7%BF%81%E6%81%BAC.assets/image-20210625194039494.png)

- 第二行：试图直接求出数组a的地址

其实正确方法应该是第一行

- 数组内相邻单元的地址相差 4

# 9.1.2 指针

- 指针：保存地址的变量：保存 &取地址符 取得变量地址 的变量

````c
int*p=&i;
//p是一个指针
//*表示P这个指针指向的是一个int类型的整数
//把i的地址交给p ，p的值是i的地址（p指向了i，i一个实际的变量）
int* p,q
  or
int *p,q
//p是一个指针，指向了int，q是一个普通int类型的变量
//把星号加给了p，*p是一个int类型的整数，于是p是一个指针
int *p,*q
//p,q都是指针
````

- 普通变量，里面的内容就是实际的值

指针变量，里面的内容是 别的变量的 地址

- 作为参数的指针

```c
void f(int *p);
//f函数要一个int的指针
int i=0;
f(&i);
//调用f函数时，需要给它一个地址（非变量本身，非变量的值）
```

```c
    int i=6;
    printf("%p\n",&i);
    int *p=&i;
    printf("%p",p);//p相当于&i,p将变量作为地址输出
//两个打印的数一样
```

```c
void f(int *p);
int main(void)
{
 int i=6;
 f(&i);
 return=0;
}
void f(int *P)
{
  printf("p=%p\n",p);
}
//带指针的函数，可以访问函数外部i的能力（函数内外不值是值的传递）
//访问“读入，写入
```

 ![image-20210626102213834](%E7%BF%81%E6%81%BAC.assets/image-20210626102213834.png)

- 单目运算符，只有一个算子

```c
 int i=6;
 printf("%p\n",&i);
 int *p=&i;
 printf("%d",*p);//打印6
//通过p这个指针，访问到了int i的值

```

![image-20210626103945088](%E7%BF%81%E6%81%BAC.assets/image-20210626103945088.png)

- 左值：表达式运算的结果

- &：取地址；

  *：取得地址所代表的变量

![image-20210626105017541](%E7%BF%81%E6%81%BAC.assets/image-20210626105017541.png)

#  9.1.3 指针的使用 

![image-20210626110736401](%E7%BF%81%E6%81%BAC.assets/image-20210626110736401.png)

 ```c
 void swap(int *pa,int *pb);
 int main(void)
 {
   int a=5;
   int b=6;
   swap(&a,&b);
   printf("a=%d,b=%d\n",a,b);
   return 0;
 }
 void swap(int *pa,int *pb)//*(&a)
 {
 int t=*pa;
   *pa=*pb;
   *pb=t;
 }
 ```

![image-20210626112300375](%E7%BF%81%E6%81%BAC.assets/image-20210626112300375.png)

- 函数返回值只能返回一个，用指针可以返回多个值，可以用参数把结果带出来（int *min,int*max)

```c
//寻找数组的最大最小值
void minmax(int a[],int len,int *max,int *min);//int len：数组元素个数
int main(void)
{
  int a[]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,55,};
  int min,max;
  minmax(a,sizeof(a)/sizeof(a[0]),&min,&max);
  printf("min=%d,max=%d\n",min,max);
  return 0;
}
void minmax(int a[],int len,int *min,int*max)//找出最大最小值
{
  int i;
  *min=*max=a[0];//*&min
  for(i=1;i<len;i++){//i=0在上一行设置过了
    if(a[i]<*min){
      *min=a[i];
    }
    if(a[i]>*max){
      *max=a[i];
    }
  }
}
```



- 函数返回运算的状态，结果通过指针返回。函数在运算是可能得不到正确的结果，这时常用的套路是让函数 返回特殊的不属于有效范围内的值 来表示出错

一般失败返回0，-1.但是如果返回的失败的数值 都是有效的可能结果时，就无法通过返回值来表达运算是否正确，

就需要分开返回：函数的状态用return来返回，函数实际的值用指针参数来返回

```c
//@return，如果出发成功，返回1；否则返回0
//返回0表示出错
//计算整数除法
int divide(int a,int b,int *result);
int main(void)
{
  int a;
  int b;
  int c;
  scanf("%d %d",&a,&b);
  if(divide(a,b,&c)){
    printf("%d/%d=%d\n",a,b,c);
  }
  return 0;
}
int divide(int a,int b, t)
{
 int ret=1;
  if(b==0)ret=0;
  else{
    *result=a/b;
  }
  return ret;
}
```

- 有的语言可以通过异常机制来解决这个问题

- 指针变量作为本地变量必须先定义指向变量，再使用

# 9.1.4指针与数组

- 数组传到函数参数里面，函数里面的数组和函数之外（传进函数里面的数组）是同一个

- 函数里面参数数组写空的方括号

Void minmax(int a[],int len,int *min,int *max){}

原因就是它其实是个指针

它形式上是数组，可以当数组用

![image-20210626172550548](%E7%BF%81%E6%81%BAC.assets/image-20210626172550548.png)

- 上图在参数表内出现是等价的，而不是类型是等价的

- 对于下图：a==&a[0];

a的地址就是a[0]的地址

![image-20210627112733793](%E7%BF%81%E6%81%BAC.assets/image-20210627112733793.png)



```c
//对指针做【】运算符
int min=2;
int *p=&min;
printf("*p=%d\n",*p);//*p取回变量的值
printf("p[0]=%d\n",p[0]);//p[0],把p当作min[0]（这里把min视作一个数组，只有min[0]有效，一个元素，就是min的值）
//两个打印相等 
```

```c
//对指针做*运算符
int a[]={100,200，};
printf("%d",*a);
//打印100
```

```c
//数组变量是const的指针
int b[]--->int *const b;
//b是一个常数，不能被改变，它是这个数组，不能代表别的数组。所以是常量指针。
//两个数组直接不能直接赋值
//b所代表变量的地址不能改变，不可代表别的数组
```

# 9.1.5 指针与const

- 指针是const：变量的地址不能改变：int *const q=&i;  	q只能指向i，**q不能改变**

*q=26;  i不是const,可以这么做

q++；  不行，q是const

- Const int * p=&i; 

or

int const *p=&i;

不可以通过p来修改i：*p=26; 不行*

***p是不能修改**

![image-20210627121732161](%E7%BF%81%E6%81%BAC.assets/image-20210627121732161.png)

- const int a[]={1,2,3,4,};

a 本身就是const，const int a：a这个数组的每个元素都不能改变 

- 数组传到函数参数里面，函数里面的数组和函数之外（传进函数里面的数组）是同一个

原因是：数组传入函数时实际上传递的是地址，所以在函数内部可以修改数组的值

为了不让数组在函数内被修改，可以用const int a[]

int sum(consy int a[],int length);

# 9.2.1 指针运算

- 指针运算：在这两个地址之间有几个该类型的东西在

- 一个指针+1   或-1：

实际上加/减的是   地址除以sizeof（类型）的值 

如果类型是char:  sizeof(char)=1

如果类型是int：  Sizeof(int)=4

-  Char *p=ac;     ac数组

*p---->ac[0]

*(p+1)-------->ac[1]

![image-20210630205346134](%E7%BF%81%E6%81%BAC.assets/image-20210630205346134.png)

![image-20210630205549190](%E7%BF%81%E6%81%BAC.assets/image-20210630205549190.png)

- 对于数组可以定义指针的时候 不 加&

对于数组里 元素 的指针定义的时候 要加&

```c
char ac[1,2,3,4,5,};
char *p=ac;
        //等价于
        char *p=&ac[0];
char *p1=&ac[2];
```

![image-20210630211629837](%E7%BF%81%E6%81%BAC.assets/image-20210630211629837.png)

-  p++,++是后缀：p++的结果是p+1以前的结果

- 遍历数组的两个方法

```c
char ac[1,2,3,4,5,};
char *p=ac;
int i;
for(i=0;i<sizeof(ac)/sizeof(ac[0]);i++){
  printf("%d\n",ac[i]);
}
```

or

```c
char ac[1,2,3,4,5,-1,};//在数组里面加上不会用到的数字，比如-1
char *p=ac;
while(*p!=-1){
  printf("%d\n",*p++);
} 
```

![image-20210630214109921](%E7%BF%81%E6%81%BAC.assets/image-20210630214109921.png)

![image-20210630214137432](%E7%BF%81%E6%81%BAC.assets/image-20210630214137432.png)

- 现代的操作系统（如windows），都是多进程的操作系统

基本管理单元是进程（双击鼠标运行起来就是操作系统中的一个进程）

操作系统会给进程一个虚拟的操作空间

即

所有的程序在开始运行的时候都以为自己有从0开始都连续空间。

- 每个程序都有0地址，但是不能碰

所以用0地址表示特殊的事

- 如果对赋有0值的指针做了任何事情的话，系统一定会崩溃

- 如果需要表示0地址就用：NULL

![image-20210630220637000](%E7%BF%81%E6%81%BAC.assets/image-20210630220637000.png)

 

![image-20210630221423001](%E7%BF%81%E6%81%BAC.assets/image-20210630221423001.png)

- int *p=&i;

Void*q=(void *)p;    把p强制转换成void类型，交给了void型q

通过q看i：把i当作void

![image-20210630222215395](%E7%BF%81%E6%81%BAC.assets/image-20210630222215395.png)

- 1、比如数组
- 4、swap

# 9.2.2 动态内存分配

 ```c
 //定义数组的大小malloc
 #include<stdlib.h>//头文件换了
 int main(void)
 {
   int number;
   int* a;
   scanf("%d",&number);
   //数组本身就是地址
   a=(int*)malloc(number*sizeof(int));
   //sizeof 类似一个自动计算的功能, 自动计算 int 多少字节 占多少坑位
   //int * 就是给这片内存规定一下数据类型，//malloc返回的是void*，需要强制类型转化为int（a的类型）
   //定义数组的大小，交给它一段空间
   //malloc这个数组占据多少个空间（以字节为单位）
   //这里第二个int可以按需写类型
   //a的类型，强制类型转换，单位类型都一致
   int i;
   for(i=0;i<number;i++){
     scanf("%d",&a[i]);
   }
   for(i=number-1;i>=0;i--){
     printf("%d",a[i]);
   }
   free(a);//malloc有借有还
   return 0;
 }
   
 ```

![image-20210701094522344](%E7%BF%81%E6%81%BAC.assets/image-20210701094522344.png)

- 如果空间用完了，会返回0或者NULL

- free是和malloc配套的函数，把用完的空间还给系统 

**只能还申请来的空间的首地址**（不能用变过的地址）

- 良好的习惯：指针一旦定义，就初始指针为零

```c
int i;
void *p=0;//对指针初始化
int cnt=0;
free(p);
//可以,如果没有malloc，或malloc失败，free(p);不会错
```

free过了就不用再free了

# 10.1.1 字符串

- Char word[]={Hello!};

Hello!是字符数组，不是字符串

字符串：char word[]={Hello!\0};

\0就是0，使得它成了**字符串，它也是字符数组**

- 字符串一定是一个**char**的数组，但char的数组未必是字符串
- 数字0(和字符'\0'等价)结尾的char数组就是一个字符串，但如果char数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的char数组。

![image-20210701103050743](%E7%BF%81%E6%81%BAC.assets/image-20210701103050743.png)

- 0或\0是一个字节，就用\0

‘0’是字符（对人）

- 头文件 string.h
- 字符串变量几种形式：

```c
char *str="Hello";
//一个叫str的指针指向"Hello"字符串，类型是char
//char* 表示字符指针类型
char word[]="Hello";
//有一个字符数组，里面内容是Hello
char line[10]="Hello";
//line数组的大小是10个字节，里面放了Hello字符串，里面有6个字符（结尾编译器自动加一个0）
```

- 像"Hello"这样被双引号括出来的东西，是**字符串的字面量或字符串的常量**

char word[]={Hello!\0};

等价于

char word[]="Hello";

- 如果是两个相邻的字符串，且中间没有任何其他符号：会自动连接成为一个大的字符串

Printf("hhhhh,""fffff");

![image-20210701111454199](%E7%BF%81%E6%81%BAC.assets/image-20210701111454199.png)



![image-20210701111821975](%E7%BF%81%E6%81%BAC.assets/image-20210701111821975.png)

# 10.1.2 字符串变量

- %c是以字符形式输出，只输出一个字符

- 如果指针指向的内容相同，那么指针指向的地址也相同

![image-20210701121033771](%E7%BF%81%E6%81%BAC.assets/image-20210701121033771.png)

- 写成第一种，指针类型：数组不在这里

写成第二种，数组类型：数组就在这里，直接用

字符串写作指针类型，字符数组的字符元素不能被修改，只可读出

```c
char s[]="Hello";
s[0]='b';//''表示字符
printf("%c",s);
```

![image-20210701122127426](%E7%BF%81%E6%81%BAC.assets/image-20210701122127426.png)

![image-20210701122502794](%E7%BF%81%E6%81%BAC.assets/image-20210701122502794.png)

Char*可能指向一个字节，或一串连续的字节

# 10.1.3 字符串输入输出

![image-20210701123750466](%E7%BF%81%E6%81%BAC.assets/image-20210701123750466.png)

- 字符串的赋值不是再搞一个一样的字符串出来，而是搞同样一个字符串

![image-20210701124222284](%E7%BF%81%E6%81%BAC.assets/image-20210701124222284.png)

-  虽然string是一个数组，但作为参数来说（针对这一个函数），传进去scanf，接收的是一个指针。我们无法知道传入的指针到底指向多大的东西(在输入的时候不知道string有多大，除非另外告诉)

应该：

```c
char string[8];
scanf("%7s",string);
/*在scanf函数之内的%与s之间写上数字，表示最多允许读入的字符数量（比数组大小小一个，\0）
```

- 注意：

Char* string；是定义了一个没有说明指向的指针，之后 不能 对其scanf("%s",string);

需要对其初始化（使指针指向一个实际有效的地址）

- ![image-20210701170830596](%E7%BF%81%E6%81%BAC.assets/image-20210701170830596.png)
- 上图是一个空的字符串，仍有效

# 10.1.4 字符串数组

```c
char *a[]={//a[0]----->char*
  "hello",
  "world",
  "helloworld",};
//可以看作：一个元素是指针的数组，每个指针元素都指向其他变量
//一个数组每一个单元都是一个字符串
```

# 10.2.1 单字符输入输出

输入参数的类型是int类型，但是接受的只有一个字符

![image-20210701181051238](%E7%BF%81%E6%81%BAC.assets/image-20210701181051238.png)

- EOF：是一个宏end of file，它的值是-1
- 正常情况下我们不需要检查puchar的输出

![image-20210701181609210](%E7%BF%81%E6%81%BAC.assets/image-20210701181609210.png)

返回EOF表示结束

```c
int main(int argc,char const *argv[])
  //int argc整数
  //char const *argv[]字符串数组
  //整数告诉我们后面的数组有多少个字符串
{
  int ch;
  while((ch=getchar())!=EOF){
    putchar(ch);
  }
  printf("EOF\n");
  return 0;
}
```

前面介绍的main函数都是不带参数的。因此main 后的括号都是空括号。实际上，main函数可以带参数，这个参数可以认为是 main函数的形式参数。Ｃ语言规定main函数的参数只能有两个， 习惯上这两个参数写为argc和argv。因此，main函数的函数头可写为： main (argc,argv)Ｃ语言还规定argc(第一个形参)必须是整型变量,argv( 第二个形参)必须是指向字符串的指针数组。加上形参说明后，main函数的函数头应写为： 
main (argc,argv)
int argv;
char *argv[];或写成：
main (int argc,char *argv[])

- 返回EOF表示输入结束了 

- 在键盘上按的所有东西是，行编辑的动作

键盘与程序之间有shell，在键盘按下回车键之前，打的字都在shell那里

按下回车以后，在shell那里有一个很大的缓冲区，把按下回车以前的东西都填在那里。缓冲区实际上可以看做内存中的字符串数组 

Ctrl-z:把shell关闭

Ctrl+c:把程序关闭掉 

- 标准输入（standard input，键盘输入

scanf 之后一般在等待你输入嘛 你用键盘输入一些字母数字 -> 最后这些数据会进入一条管道里 -> 这条管道就叫 标准输入）

、输出主要由缓冲区和操作方法（如scanf）两部分组成

- putchar的作用主要是向**输出**缓冲区中**写入**一个字符。

  getchar的作用主要是向**输入**缓冲区中**读取**一个字符。如果碰到文件结尾，返回-1\

- 定义宏：（replacement)

#define SB "guawa"

将SB替换为guawa

用的时候不需要加引号  

定义被替代的内容大写

- 将类型取另外的名字：

Typedef int degree;

将int类型重新命名degree

![image-20210710154752828](%E7%BF%81%E6%81%BAC.assets/image-20210710154752828.png)

# 10.2.2 函数strlen

- 处理字符串的函数

![image-20210710154910070](%E7%BF%81%E6%81%BAC.assets/image-20210710154910070.png)

- 这些函数在头文件string.h内，使用include<string.h>

![image-20210710155053262](%E7%BF%81%E6%81%BAC.assets/image-20210710155053262.png)

- Len----->lenth

```c
//%lu表示输出无符号长整型整数 (long unsigned)
//size_t是一个类型:本质是 unsigned long int 无符号long整数
#include<stdio.h>
#include<string.h>
int main()
{
  char line[]="Hello";
  printf("strlen=%lu\n",strlen(line));
  printf("sizeof=%lu\n",sizeof(line));
  return 0;
}
/*
   输出：
strlen=5
sizeof=6（\n)
*/
```

等价于

```c
#include<stdio.h>
size_t mylen(const char *s)
{
  int idx=0;
  while(s[idx]!='\0'){
    idx++;
  }
  return idx;
}
int main()
{
  char line[]="Hello";
  printf("strlen=%lu\n",mylen(line));
  return 0;
}

```

- 函数的类型int main的int等等，体现在返回值的类型

# 10.2.3字符串函数 strcmp

![image-20210710163312262](%E7%BF%81%E6%81%BAC.assets/image-20210710163312262.png)

- Compare 比较两个字符串

```c
#include<string.h>
int main ()
{
  char s1[]="abc";
  char s2[]="Abc";
  printf("%d\n",strcmp(s1,s2));
  printf("%d\n",'a'-'A');//得出的结果是s1-s2的差值
  return 0;
}
```

数组无法直接比较s1==s2，比较的将是它们的地址

空格的字符量是32，0\的字符量是0

等价于

```c
int mycmp(const char* s1,const char *s2)
{
  int idx=0;
  while(s1[idx]==s2[idx] && s1[idx]!='\0'){
    idx ++;
  }
  return s1[idx]-s2[idx];
}
int main ()
{
  char s1[]="abc";
  char s2[]="Abc";
  printf("%d\n",mycmp(s1,s2));
  return 0;
}//数组法
```

或者

```c
int mycmp(const char* s1,const char *s2)
{
  while(*s1==*s2 && *s1!='\0'){
    s1++;
    s2++;
  }
  return *s1-*s2;
}
int main ()
{
  char s1[]="abc";
  char s2[]="Abc";
  printf("%d\n",mycmp(s1,s2));
  return 0;
}//指针法
```

    # 10.2.4字符串函数 strcpy

![image-20210710172519712](%E7%BF%81%E6%81%BAC.assets/image-20210710172519712.png)

-  Copy,把第二个参数里的字符串拷贝到第一个参数的空间里

重合：移动内存

不重合：拷贝到哪里就是哪里

实际上是得到一个指针，指向外面的字符串

![image-20210710173327215](%E7%BF%81%E6%81%BAC.assets/image-20210710173327215.png)

一般来说，复制一个字符串：

Strcpy(s1,s2);

s1字符数可以大于s2,结果s2==s1

s2字符数 不能 大于s1，跑不了

注意：数组被定义后不能修改内存大小

```c
int main(void)
{
  char s1[40]="1345";
  char s2[]="1宿5555";
  strcpy (s1,s2);
    printf ("%s\n",s1);
    printf("%s",s2);
    return 0;
}//指针法
```

```c
char *dst=(char*)malloc(strlen(src)+1);
strcpy(dst,stc);
/*
定义了一个dst名字的指针
malloc分内存:分的大小是src字符串的长度+1（\0）
分的内存是要存放char类型的
把内存给dst
把src的字符串复制给dst
与其说是复制，更像是替代*/
```

等价于

```c
char* mycpy(char* dst,const char* src)
{
  int idx=0;
  while(src[idx]){//src[idx!=0]
    dst[idx]=src[idx];
    idx++;
  }
  dst[idx]='\0';
  return dst;//dst当数组名，直接输出字符串
}
int main()
{
  char s1[]="abc";
  char s2[]="cba";
  mycpy(s1,s2);
  return 0;
}//数组法
```

```c
char* mycpy(char* dst,const char* src)
{
  while(*src){//*src!=0
    *dst++ = *src++;//一个个往下挪
}
  *dst='\0';
  return dst;
}
int main()
{
  char s1[]="abc";
  char s2[]="cba";
  mycpy(s1,s2);
  return 0;
}//指针法
```

等价于

```c
char* mycpy(char* dst,const char* src)
{
  
  while（*dst++ = *src++）{;}//因为默认while（）条件里面！=0，所以当* src是0的时候自动打破，否则就不断赋值
  *dst='\0';
  return dst;
}
int main()
{
  char s1[]="abc";
  char s2[]="cba";
  mycpy(s1,s2);
  return 0;
}//指针法
```

mycpy(s1,s2);

s1字符数可以大于s2,结果s2==s1

s2字符数 可以 大于s1，结果s2==s1,算法以s2为准，不断扩展s1的大小

# 10.2.5字符串函数strcat

![image-20210711092239317](%E7%BF%81%E6%81%BAC.assets/image-20210711092239317.png)

- strcpy是从【0】开始拷贝，strcat是从【strlen（s1）】开始拷贝

![image-20210711092619645](%E7%BF%81%E6%81%BAC.assets/image-20210711092619645.png)

- 尽可能不要直接使用字符串拷贝
- 安全版本

![image-20210711092726781](%E7%BF%81%E6%81%BAC.assets/image-20210711092726781.png)

- 多的n表示，能拷贝最多多少个字符

函数strncpy(s2,s1,n)  将s1复制到s2或从s1复制n个字符到s2。如果s1包含的字符少于 n，则strncpy函数将用空值字符填充s2。

- 比较前几个字符

# 10.2.6字符串搜索函数

![image-20210711100048131](%E7%BF%81%E6%81%BAC.assets/image-20210711100048131.png)

```c
char* strchr(const char* s,int c);
//要在s字符串里找第一个c的位置，返回指针
//从左边开始找,找到该字符以及该字符右边的字符
char* strrchr(const char* s,int c);
//从右边开始找，找到该字符以及该字符右边的字符
```

```c
char s[]="hello";
printf("%s",strchr(s,'l'));
//打印llo

//等价于
char s[]="hello";
char *p=strchr(s,'l');//返回指针
printf("%s\n",p);//指针当数组，直接打印

//找第二个l
char s[]="hello";
char *p=strchr(s,'l');//p="llo",在里面找第二个l
p=strchr(p+1,'l');//P+1跳过第一个找到的，从后面开始找
printf("%s\n",p);

//只要he
    char s[]="hello";
    char *p=strchr(s,'l');
    char c =*p;//c=='l'
    *p='\0';//把s字符串打断
    char *t=(char*)malloc(strlen(s)+1);
    strcpy(t,s);
    *p=c;//把l放回去，恢复字符串
    printf("%s\n",t);
    printf("%s\n",s);
    free(t);
```

![image-20210711105752260](%E7%BF%81%E6%81%BAC.assets/image-20210711105752260.png)

Strcasestr：忽略大小写

# 11.1.1枚举

- 常量符号化：用符号而不是具体的数字表示程序中的数字（可读性）

- 枚举直接定义多个int类型的常量（对于连续相关的命名要求时使用）

![image-20210711111133237](%E7%BF%81%E6%81%BAC.assets/image-20210711111133237.png)

```c
enum color{red,yellow,green};//声明新的数据类型叫color，enum color,叫做color的枚举类型，实际上是const int类型
void f(enum color c);//定义一个函数，f函数的参数是enum color c
           int main()
           {
             enum color t=red;//定义t变量，值是red==0
             scanf("%d",&t);
             f(t);//把t的值传给f函数,enum color c，t常量就是一个傀儡
             return 0;
           }
           void f(enum color c)
           {
             printf("%d\n",c);
           }
```

- 自动计数的枚举：enum color{a,b,c,sum};

sum的值就是它前面有几个常量，可以用来计数

```c
enum COLOR{ RED, YELLOW, GREEN, MumCOLORS};//这一行光计数用了
int main()
{
  int color = -1;
    char *ColorNames[MumCOLORS]={//计数用了
    "red","yellow","green",
  };
  char *colorName=NULL;//初始化
  printf("输入你喜欢的颜色代码：");
  scanf("%d",&color);
    if(color>=0 && color< MumCOLORS){//计数用了
    colorName= ColorNames[color];
  }else{
    colorName="unknown";
  }
  printf("你喜欢的颜色是%s\n",colorName);
  return 0;
}
```

![image-20210711162405290](%E7%BF%81%E6%81%BAC.assets/image-20210711162405290.png)

- red=1,yellow=2,green=5

![image-20210711162612360](%E7%BF%81%E6%81%BAC.assets/image-20210711162612360.png)

# 11.2.1结构类型

- 一个结构是一个复合的各种类型，用一个变量表达多个数据

```c
struct date//声明一个结构类型 date（定义一个类型struct date)，大括号里面是结构的成员，每一个date里面都有一个month,day,year
{ int month;
  int day;
  int year;
};//注意分号
int main()
{
struct date today;//定义这个结构类型的变量，每个结构变量都有month,date,year
today.month=07;
today.day=31;
today.year=2021;
printf("Today's date is %i-%i-%i.\n",today . year,today . month,today . day);
return 0;
}
```

![image-20210711164058638](%E7%BF%81%E6%81%BAC.assets/image-20210711164058638.png)

```c
//声明结构的形式
struct point{//上面声明结构，下面定义变量
  int x;
  int y;
};
int main(){
  struct point p1,p2；//定义结构名称的时候，struct+结构名称+变量名称
}

//-------------------------------------
struct{//这个结构没有名字
  int x;
  int y;
}p1,p2;

//--------------------------------------
//声明的呀、同时定义变量
struct point{
  int x;
  int y;
}p1,p2;
```

- 变量的初始化：放在函数内部的变量是本地变量，本地变量没有默认的初始值

```c
struct date{
  int month;
  int day;
  int year;
};
int main()
{
struct date today={01,31,2021};//法1，定义类型变量并初始化
struct date thismonth={.month=7, .year=2021};//法2，可以不按顺序定义，没有赋值的就是0（和数组一样）
printf("Today's date is %i-%i-%i.\n",//%i表示有符号十进制整数,这里用%d也可以
       today.year,today.month,today.day);
  printf("This month is %i-%i-%i.\n",
         thismonth.year,thismonth.month,thismonth.day);
return 0;
}
```

- 数组与结构：

数组不同单元，结构不同成员，单元类型一样，成员类型可以不一样s

数组用【】带下标访问单元，结构用 . 运算符和名字访问成员 today.day（today变量里的day成员）

出现在 . 左边的是结构变量 

![image-20210711172619748](%E7%BF%81%E6%81%BAC.assets/image-20210711172619748.png)

```c
p1=(struct point){5,10};
//把{5,10}直接强制类型转换成struct point类型，赋值给p1类型变量
```

数组不能之间数组直接赋值，但是结构可以

![image-20210711173512042](%E7%BF%81%E6%81%BAC.assets/image-20210711173512042.png)

- Date是结构类型，today是结构变量

# 11.2.2结构与函数

- 结构类型的也可以作为函数的参数 
- 函数中作为参数的结构和main里的结构不一样，定义一个新的结构把值复制进去

![image-20210711211411528](%E7%BF%81%E6%81%BAC.assets/image-20210711211411528.png)

```c
//读入结构
struct point{//创建struct point类型
  int x;
  int y;
};


struct point getStruct(void);
void output(struct point);
int main()
{
  struct point y={0,0};
  y=getStruct();//结构可以直接赋值（它们的类型一样）
  output(y);
    return 0;
}
struct point getStruct(void)//定义一个函数，返回struct point类型，没有参数
{
  struct point p;
  scanf("%d",&p.x);
  scanf("%d",&p.y);
  printf("%d,%d\n",p.x,p.y);
  return p;//返回读入的结构
}
void output(struct point p)
{
  printf("%d,%d",p.x,p.y);//这个p与上面的不是一个
}
```

- 传结构给函数作为参数时，最好，传结构的**指针**给函数作为参数（不费空间）

![image-20210711223202983](%E7%BF%81%E6%81%BAC.assets/image-20210711223202983.png)

最后一行（p所指的month)替代倒数第二行

```c
struct point{//创建struct point类型
  int x;
  int y;
};
struct point* getStruct(struct point *p)//定义一个getStruct函数，返回一个指向结构的指针，参数也是指向结构变量p的指针
{
  scanf("%d",&p->x);
  scanf("%d",&p->y);
  printf("%d,%d\n",p->x,p->y);
  return p;
}//套路：传进指针到函数里面，再返回指针  
void output(struct point p)
{
  printf("%d,%d",p.x,p.y);
}
void print(const struct point *p)
{
  printf("%d,%d",p->x,p->y);
}
int main ()
{
  struct point y={0,0};
  getStruct(&y); 
  output(y);//法1
  output(*getStruct(&y));//法2=法1，*getStruct(&y)--->*(*y)-->y
  print(getStruct(&y));//法3,outpute打印结构，print打印指针
  *getStruct(&y)=(struct point){1,2};//把{1,2}赋值给y
    print(&y);
}
```

# 11.2.3结构中的结构

```c
struct date dates[2];
//创建一个数组，数组的每个单元都是一个结构，共2个单元
//数组的名字是dates
struct date dates[]={
  {4,5,2020},{2,4,2021}
};
```

```c
struct time{
  int hour;
  int minutes;
  int seconds;
};
struct time timeUpdate(struct time now)
{//一秒之后的时间
  ++now.seconds;
  if(now.seconds==60){
    now.seconds=0;
    ++now.minutes;//之后的在上面的基础上
    if(now.minutes==60){
      now.minutes=0;
      ++now.hour;
      if(now.hour==24){
          now.hour=0;
      }
    }
  }
    return now;
}
  int main()
  {
    struct time testTimes[5]={
      {11,59,59},{12,0,0},{1,29,59},{23,59,59},{19,12,27}
    };
    int i;
    for(i=0;i<5;++i){
      printf("Time is %.2i:%.2i:%.2i",
    //：printf("%.3lf",d);其中的“.3”就是小数点后保留三位小数。
             	testTimes[i].hour,testTimes[i].minutes,testTimes[i].seconds);
      testTimes[i]=timeUpdate(testTimes[i]);
      printf("...one second later is %.2i:%.2i:%.2i\n",
             testTimes[i].hour,testTimes[i].minutes,testTimes[i].seconds);
    }
    return 0;
  }
```

```c
//定义一个矩形，需要两个坐标
struct point{
  int x;
  int y;
};//定义一个坐标
struct rectangle{//定义一个矩形，里面有两个坐标
  struct point pt1;
  struct point pt2;
};
/*如果有一个矩形，就有：
rectangle.pt1.x----->矩形内坐标1的横坐标

```

![image-20210712220041694](%E7%BF%81%E6%81%BAC.assets/image-20210712220041694.png)

```c
/*如果有一个指针rp，指向rectangle
rectangle.pt1.x
==
rp->pt1.x
```

- 数组&结构混合：

数组里面有结构，结构的数组

结构里面有数组，数组的结构

结构中结构的数组，数组里面的单元是结构，结构里还有别的结构

```c
//结构中的结构
struct point{
  int x;
  int y;
};
struct rectangle{//每个矩形
  struct point p1;
  struct point p2;
};
void printRect(struct rectangle r)
{
  printf("<%d,%d>to<%d,%d>\n",r.p1.x,r.p2.y,r.p2.x,r.p2.y);
}
int main()
{
  int i;
  struct rectangle rects[]={
    {{1,2},{3,4}},
    {{3,5},{7,8}}
  };//2 rectangles
  for(i=0;i<2;i++){
  printRect(rects[i]);
}
    return 0;
}
```

# 11.3.1类型定义

![image-20210712222701159](%E7%BF%81%E6%81%BAC.assets/image-20210712222701159.png)

![image-20210712222805928](%E7%BF%81%E6%81%BAC.assets/image-20210712222805928.png)

- typedef先加实际类型的名字，再加自己重新的命名

Typedef和新的命名之间的都是类型

```c
typedef struct ADate{
  int month;
  int day;
  int year;
}Date;
/*将
struct ADate{
  int month;
  int day;
  int year;
};
这个类型命名为Date
```

