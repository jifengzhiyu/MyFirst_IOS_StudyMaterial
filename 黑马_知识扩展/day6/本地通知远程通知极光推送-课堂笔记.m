#pragma mark - 一. 本地通知

#pragma mark 1. 推送通知的介绍(了解)

一. 推送通知有5种不同的呈现效果
1. 在屏幕顶部显示一块横幅（显示具体内容）
2. 在屏幕中间弹出一个UIAlertView（显示具体内容）
3. 在锁屏界面显示一块横幅（锁屏状态下，显示具体内容）
4. 更新app图标的数字（说明新内容的数量）
5. 播放音效（提醒作用）

通知中心 : 发送过来未处理的通知, 将会在通知中心中统一呈现

二. 用户可以设置, 显示横幅还是UIAlertView. 默认是横幅

三. 用户也可以决定是否要开启以下4个功能：
显示App图标数字
播放音效
锁屏显示
显示在“通知中心”


#pragma mark 2. 创建本地通知(掌握)
1. 创建本地通知对象
2. 设置属性
    触发时间
    触发显示的内容
    声音
    应用程序图标标记
3. 调度本地通知 (将本地通知加入本地通知调度池)
4. 注册通知(iOS8以后才出现的) iOS8开始增加了用户隐私的保护, 很多的事项都需要程序员手动写代码获取权限

注意: 请求用户权限, 只需要做一次, 那么如果有多个通知发生, 最好还在didFinishLaunchingWithOptions.

二. 其他属性和方法
1. 重复调用 --> 如果设置了重复, 那么调度池不会自动销毁通知
2. 重复所依据的日历
3. 是否显示锁屏时的slider文字, 以及提醒样式的按钮文字
4. 显示锁屏时的slider文字, 以及提醒样式的按钮文字

5. 删除所有通知 当前程序注册的所有通知都没了
6. 获取所有通知 后 删除单个通知

#pragma mark 3. 通知的处理1-跳转界面(掌握)
如果程序在前台运行, 则不会显示横幅信息 , 自动跳转
如果程序在后台运行, 会显示横幅信息, 而且点击后, 能实现通知的消息处理 点击跳转

1. 增加用户信息属性
2. 在AppDelegate里面实现接受到本地通知时的代理方法
3. 在此方法中可以获取userInfo, 然后自行处理跳转逻辑

4. 如果程序在前台运行, 那么我们该不主动发生跳转行为
    我们可以获取应用程序的状态, 进行判断, 如果在前天, 就不跳转


#pragma mark 4. 通知的处理2-程序退出(掌握)
1. 判断是否有本地通知的值
2. 在AppDelegate首次启动时调用的方法中获取本地通知
3. 调用收到通知跳转的方法

注意: 如果首次启动, 那么本地通知的值为null, 如果为空, 我们就没有必要去调用通知处理的方法


#pragma mark 5. 分类的设置(了解)
分类的设置 --> 设置快捷回复
一. 实现快捷回复的功能
1. . 创建分类 注意使用可变子类 UIUserNotificationCategory
    1  设置标识符
    2 设置按钮 --> 按钮是多个, 就2个

2. 设置前台按钮 --> 注意要使用可变子类 点击后能够回到原程序的就是前台
    1 设置按钮标识符
    2 设置按钮的模式
    3 设置按钮的标题 --> 按钮的文字

3. 放在NSSet中, 放到方法中即可

#pragma mark - 二. 远程通知

#pragma mark 1. 远程推送通知原理(掌握)
一.开发iOS程序的推送功能, iOS端需要做的事
1.请求苹果获得deviceToken
    UDID : 目的是将来可以找到手机
    Bundle ID : 目的是将来可以找到手机中的程序
2.得到苹果返回的deviceToken
3.发送deviceToken给公司的服务器
4.监听用户对通知的点击


#pragma mark 2. 配置证书(掌握)
一. 调试iOS的远程推送功能, 必备条件:
1.真机

2.调试推送需要的证书文件
1> aps_development.cer : 某台电脑就能调试某个app的推送服务
2> ios_development.cer : 让电脑具备真机调试的能力(调试设备)
3> iphone5_qq.mobileprovision : 某台电脑就能利用某台设备调试某个程序

二.发布具有推送服务的app
1> aps_production.cer : 如果发布的程序中包含了推送服务,就必须安装这个证书
2> ios_distribution.cer  : 让电脑具备发布程序的能力
3> qq.mobileprovision  : 某台电脑就能发布某个程序

三. 如何配置证书
1. 必需一个配置了精确的Bundld ID调试证书
2. 创建调试用的推送证书--> 流程跟创建普通调试证书一样, 多了一个选择BundlD ID的过程 (如果之前配置的是通配符Bundld ID ,则无法使用Push功能)
3. 配置完成之后, 需要依次安装
cn.itheima.heima4

#pragma mark 3. 远程推送代码实现(掌握)
1. 确保Bundle ID 是一致的
2. 注册远程推送 --> 就是将UDID , Bundle ID  发给苹果
3. 代理方法中获取Token
4. 将token发送给自家的服务器
5. 在xcode7之后, 最好到项目的Capabilities中打开Push Notifications选项, 否则可能获取的Token不一致(也就是无法获取正确的Token)

处理结果时
2种方案
1. didReceiveRemoteNotification
didFinishLaunchingWithOptions

2.didReceiveRemoteNotification: fetchCompletionHandler:
// 前台/后台/应用程序退出  三种情况下都可以收到消息
// 需要配置一个值, 在项目--> Target
// 如果实现了此方法, 那么上面的方法将会弃用, 此时, 也就不需要在程序启动的代理方法中写代码了


#pragma mark - 三. 极光推送

#pragma mark 1. 第三方推送SDK-极光推送 (了解)


#pragma mark 2. 极光推送的集成与调试(掌握)

